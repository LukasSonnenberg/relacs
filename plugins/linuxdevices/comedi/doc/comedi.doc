/*!
\mainpage Comedi Relacs Plugins

\brief Interfaces to the Comedi data acquisition library for normal analog input and output as well as for dynamic clamp.


Comedi (linux control and measurement device interface) provides hardware drivers
to many data acquisition boards with a common library interface.
The RELACS Comedi plugins access data acquisition boards by means of the Comedi library.

For general information about Comedi and a list of supported devices
see http://www.comedi.org

\section comedicontent Content
- \ref comediintro
- \ref installcomedi
- \ref installrtai
- \ref udev
- \ref buffer
- \ref calibration
- \ref dynamicclamp
- \ref rtailinks


\section comediintro Introduction

If you only need normal ("streaming", asynchronous) data acquisition
as it is implemented by the ComediAnalogInput and ComediAnalogOutput plugins,
then follow the instructions in \ref installcomedi.

If you want to use dynamic clamp, i.e. some realtime computation,
as it is implemented by the DynClampAnalogInput and DynClampAnalogOutput plugins,
then you need to install a real-time linux kernel first, as described in
\ref installrtai.


\section installcomedi Install comedi

You should install the \c Comedi drivers and library prior to
configuring RELACS, so that ./configure can detect the presence of the
\c Comedi library.  Un recent linux distributions comedi is available
as a package (libcomedi-dev) and the kernel moduls are already in the
kernel. However, these are not the most recent version of comedi and
therefore you should reinstall the comedi drivers and the comedi
library from scratch as described in the following sections


\subsection installkernel Linux kernel

In order to be able to install the \c Comedi drivers you need to have a kernel source tree
that matches your running kernel image. Either compile your own kernel from scratch 
(section \ref installvanillakernel , takes some time),
or make sure that you get a matching source tree for your kernel image
(section \ref installkernelsources).


\subsubsection installkernelsources Install sources for an existing kernel

-# Get the soure that matches your kernel. 
On Ubuntu/Debian you get the kernel source and header files
matching your running kernel image by executing as root
\code
$ cd /usr/src
$ apt-get install dpkg-dev
$ apt-get source linux-image-`uname -r`
$ apt-get install linux-headers-`uname -r`
\endcode
If \c apt-get \c source tells you "E: You must put some 'source' URIs in your sources.list"
then you need to enable the source repositories for the package manager. For this
open with your favorite editor \c /etc/apt/sources.list and the \c *.list files in 
\c /etc/apt/sources.list.d/. Remove the comments in front of the lines
that start with \c "deb-src". Then run
\code
$ apt-get update
\endcode
to resynchronize the package index files with the new repositories. Now 
\c apt-get \c source should be able to download the kernel sources.
After downloading the kernel source create a link to the kernel source:
\code
ln -s linux <kernel-source>
\endcode
where \c <kernel-source> is the kernel source installed by \c apt-get.
Note that often the kernel source directory that you installed with \c apt-get
has a different name than the name of the currently running kernel that \c uname -r
returns. Use \c ls \c -rtl to list the directories in the \c /usr/src folder.
The last one is the one that was added by \c apt-get \c source.
Now you can \c cd into the kernel source directory
\code
$ cd linux
\endcode
-# Copy the kernel configuration file of your kernel image to the source:
\code
$ cp /boot/config-`uname -r` .config
\endcode
-# Make sure the file \c Module.symvers is also in your source. 
On Ubuntu/Debian you find it in the corresponding \c linux-headers directory:
\code
$ cp ../linux-headers-`uname -r`/Module.symvers .
\endcode
-# Run
\code
$ make oldconfig
$ make prepare
$ make scripts
\endcode

\subsubsection installvanillakernel Compile your own kernel

-# Either get a vanilla kernel from http://www.kernel.org,
e.g. http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.28.9.tar.bz2,
place the tar file in /usr/src and unpack it as root with
\code
$ cd /usr/src
$ tar xjvf linux-2.6.28.9.tar.bz2
\endcode
(replace \c linux-2.6.28.9 by the directory name of your new kernel source).
Create a softlink to your kernel source 
\code
$ ln -s linux-2.6.28.9 linux
$ cd linux
\endcode
-# Reuse your current configuration (replace \c XXX by the name of your running kernel):
\code
$ cp /boot/config-XXX .config
$ make oldconfig
\endcode
Hit \c enter to all the (probably many) questions.
-# Steps 3. to 6. describe the normal way to compile a linux kernel.
On Debian systems there is an elegant alternative that is described
in step 9. below.
First, you configure your kernel by calling
\code
$ make menuconfig
\endcode
(You might needto install the following packages first: \c apt-get \a install \c make \c gcc \c ncurses-dev \c zlib1g-dev).
Possible settings you might want to change are:
  - Processor type and features: 
    - Select your Subarchitecture Type (PC-Compatible) - this option does not exist on newer kernels
    - Select the right Processor family (you find the name of your processor by looking at \c /proc/cpuinfo,
      check \c "help" to find out, which Processor family you have to select)
    - Select "Preemption Model (Preemptible kernel (Low-Latency Desktop))"
  .
Leave the configuration dialog by pressing "Exit" until you are asked "Save kernel config?".
Select "Yes".
-# Then compile and install (as root) the kernel
\code
$ make && make modules && make modules_install && make install
\endcode
This takes quite a while.
-# Finally you might need to create a RAM disk image file,
if \c make \c install did not create a \c /boot/initrd-2.6.28.9 file already:
\code
$ cd /boot
$ update-initramfs -c -k 2.6.28.9
\endcode
-# Check the grub menu whether your new kernel was added.. 
With \c grub \c v1 (default up-to Debian Lenny) 
there should be an entry like this in \c /boot/grub/menu.lst:
\code
title           Debian GNU/Linux, kernel 2.6.28.9
root            (hd0,0)
kernel          /boot/vmlinuz-2.6.28.9 root=/dev/sda1 ro quiet
initrd          /boot/initrd.img-2.6.28.9
\endcode
With \c grub \c v2 (default since Debian Lenny) 
there should be an entry like this in \c /boot/grub/grub.cfg:
\code
menuentry "Ubuntu, Linux 2.6.28.9-rtai" {
        recordfail=1
        if [ -n ${have_grubenv} ]; then save_env recordfail; fi
        set quiet=1
        insmod ext2
        set root=(hd0,1)
        search --no-floppy --fs-uuid --set cc028ecc-e801-4f23-a86d-ae2d10a71294
        linux   /boot/vmlinuz-2.6.28.9-rtai root=UUID=cc028ecc-e801-4f23-a86d-ae2d10a71294 ro   quiet splash
        initrd  /boot/initrd.img-2.6.28.9-rtai
}
\endcode
You can configure \c grub \c v2 by editing the file \c /etc/default/grub
and running \c update-grub afterwards.
-# Reboot the computer into the new kernel.
\code
$ reboot
\endcode
-# Install third party kernel modules as well,
like for example the ones for your graphics board.
For your nvidia graphics board, download the driver from
http://www.nvidia.com/Download/index.aspx?lang=en-us.
Install it by calling
\code
$ sh NVIDIA-Linux-x86_64-190.42-pkg2.run
\endcode
If you want to install the nvidia driver for a second kernel, then call
\code
$ sh NVIDIA-Linux-x86_64-190.42-pkg2.run -k 2.6.28.9-rtai -K
\endcode
(replace 2.6.28.9-rtai by the name of the kernel where you want to install the nvidia driver,
i.e. the string '\c uname \c -r' would return if that kernel is running).
-# On a Debian system there is an alternative to steps 3. - 6. for compiling a linux kernel. Do as root:
   -# Get the kernel-package
   \code
$ apt-get install kernel-package
   \endcode
   -# Configure and build the kernel:
   \code
$ make-kpkg --initrd --revision 1 --config menuconfig kernel-image
   \endcode
   You can also supply a \c -j option to tell make how many processes can be run in parallel.
   See step 3. for hints on the configuration options.
   -# Install the kernel
   \code
$ cd ..
$ dpkg -i linux-image-2.6.28.9_r1_amd64.deb
   \endcode
   -# continue with step 6.


\subsection installcomedidriver Comedi

Kernel versions 2.6.30 onwards have an experimental in-tree Comedi
implementation in the driver "staging" area. You can check whether it
works for you by following the instructions of point 11 below.  
However, we recommend installing a current version of the comedi drivers.

Here are all commands that you can throw into a shell to completely install comedi:
\code
# download comedi sources:
cd /usr/local/src
apt-get install git
git clone git://comedi.org/git/comedi/comedi.git
git clone git://comedi.org/git/comedi/comedilib.git
git clone git://comedi.org/git/comedi/comedi_calibrate.git
rm -r /lib/modules/`uname -r`/kernel/drivers/staging/comedi

# comedi:
cd /usr/local/src/comedi
apt-get install autoconf libtool
./autogen.sh
./configure
make && make install
depmod -a
cp include/linux/comedi.h /usr/include/linux/
cp include/linux/comedilib.h /usr/include/linux/

# comedilib:
cd /usr/local/src/comedilib
./autogen.sh
./configure --prefix=/usr --sysconfdir=/etc
make && make install

# comedi_calibrate:
cd /usr/local/src/comedi_calibrate
apt-get install libgsl0-dev libboost-program-options-dev
autoreconf -v -i
./configure --prefix=/usr --sysconfdir=/etc
make && make install

# setup udev permissions:
addgroup --system iocard
echo 'KERNEL=="comedi*", MODE="0660", GROUP="iocard"' > /etc/udev/rules.d/95-comedi.rules
udevadm trigger
adduser $USER iocard
\endcode
In the following the necessary steps are described in detail:

-# Download the current \c Comedi sources from the Git repository to \c /usr/local/src
as root.
\code
$ cd /usr/local/src
$ git clone git://comedi.org/git/comedi/comedi.git
$ git clone git://comedi.org/git/comedi/comedilib.git
$ git clone git://comedi.org/git/comedi/comedi_calibrate.git
\endcode
Or download the current	Git snapshots from http://www.comedi.org/download.html 
to \c /usr/local/src and unpack them
\code
$ cd /usr/local/src
$ tar xzvf comedi-HEAD-*.tar.gz
$ tar xzvf comedilib-HEAD-*.tar.gz
$ tar xzvf comedi_calibrate-HEAD-*.tar.gz
\endcode
-# You may need to install the packages: \c autoconf, \c libtool.
\code
$ apt-get install autoconf libtool
\endcode
-# Make sure that you are really running the kernel
  for which you want to install \c Comedi!
  You can check with
\code
$ uname -r
\endcode
-# Remove the Comedi staging modules to avoid conflicts:
\code
$ rm -r /lib/modules/`uname -r`/kernel/drivers/staging/comedi
\endcode
-# Change to the \c Comedi directory:
\code
$ cd /usr/local/src/comedi
\endcode
-# Generate the configuration script by calling
\code
$ ./autogen.sh
\endcode
You may ignore warnings and reminders.
-# Configure simply by calling
\code
./configure
\endcode
in case you want to install \c Comedi into your currently running kernel.
If \c /usr/src/linux is not your running kernel, then call
\code
$ ./configure --with-linuxsrcdir=/usr/src/linux
\endcode
with \c /usr/src/linux replaced by the path to the sources of the kernel
for which you want to install \c Comedi.
-# Compile
\code
$ make
\endcode
and install (as root)
\code
$ make install
$ depmod -a
\endcode
-# For some strange reason, the include files for kcomedilib \c linux/comedilib.h and 
\c linux/comedi.h are not installed by \c Comedi to \c [prefix]/include/linux .
These files are needed for compiling the kernel modules that use Comedi.
Also, RTAI expects \c Comedi include files in \c [prefix]/include/linux.
Therefore you need to copy the \c Comedi include files 
to \c [prefix]/include/linux yourself:
\code
$ cp include/linux/comedi.h /usr/include/linux/
$ cp include/linux/comedilib.h /usr/include/linux/
\endcode
-# Check loading the Comedi module:
\code
$ modprobe comedi
\endcode
If you do not get any error message, then the Comedi kernel modules were
successfully compiled and can be loaded into the kernel.
-# Check autodetection of your data acquisition board:
\code
$ udevadm trigger
$ ls /dev/comedi*
\endcode
In case the \c ls command shows something like
\code
/dev/comedi0        /dev/comedi0_subd1   /dev/comedi0_subd12
/dev/comedi0_subd0  /dev/comedi0_subd11  /dev/comedi0_subd2
\endcode
i.e. some \c comedi* character device files, your board probably was detected. Run
\code
$ comedi_test -t info -f /dev/comedi0
\endcode
to see more details about your data acquisition board (note: \c comedi_test
is part of comedilib, see below).
In case no \c /dev/comedi* device file shows up
or \c comedi_test reported an error (E: comedi_open("/dev/comedi0"): No such device),
your data acquisition board needs to be configured manually, using something like
\code
$ comedi_config /dev/comedi0 ni_mio_cs
\endcode
that can be put into the \c /etc/init.d/boot.local file, so that
the board is configured during startup of the system.
Read the man page of \c comedi_config first!
\code
$ man comedi_config
\endcode


\subsection installcomedilib Comedilib
-# You may need to install the packages: \c autoconf, \c libtool, \c bison, \c flex.
\code
$ apt-get install bison flex
\endcode
-# Change to the \c comedilib directory as root:
\code
$ cd /usr/local/src/comedilib
\endcode
-# Generate the configuration script by calling
\code
$ ./autogen.sh
\endcode
You may ignore warnings and reminders.
-# Configure comedilib to be installed in \c /usr/lib and \c /usr/include
\code
$ ./configure --prefix=/usr --sysconfdir=/etc
\endcode
If you want to have Comedlib to be installed somewhere else, specify another \c prefix.
You may want to read \c ./configure \c --help as well.
Pay attention to warnings and errors! You might need to install additional software first.
-# Compile and install (as root)
\code
$ make && make install
\endcode


\subsection installcomedicalib Comedi_calibrate
-# You may need to install the packages:  \c autoconf, \c libtool, 
   \c libgsl0-dev, \c libboost-program-options-dev.
\code
$ apt-get install libgsl0-dev libboost-program-options-dev
\endcode
-# Change to the \c comedi_calibrate directory as root:
\code
$ cd /usr/local/src/comedi_calibrate
\endcode
-# Generate the configuration script by calling
\code
$ autoreconf -v -i
\endcode
You may ignore warnings and reminders.
-# Configure
\code
$ ./configure --prefix=/usr --sysconfdir=/etc
\endcode
-# Compile and install (as root)
\code
$ make && make install
\endcode


\section installrtai Install RTAI and Comedi

For dynamic clamp you need an RTAI patched linux kernel and Comedi.

\subsection rtaikernel Linux kernel and RTAI patch

-# Download the latest RTAI (http://www.rtai.org) version (version 3.7.1) from 
the RTAI repository at http://www.rtai.org/RTAI
and put it into \c /usr/local/src as root.
-# Unpack RTAI in /usr/local/src:
\code
$ cd /usr/local/src
$ tar xjvf rtai-3.7.1.tar.bz2
$ ln -s rtai-3.7.1 rtai
\endcode
-# Check for available patches. Get a list of all patches for all architectures:
\code
$ find rtai/base/arch/ -name '*.patch' | sort
\endcode
The most recent patches for intel and amd 32 and 64-bit systems are in the x86 directory.
Decide for a patch, and remember its version number: \c hal-linux-<kernel-version>-*.patch
  -# Currently, the 2.6.28.9 works, the patch for the 2.6.29 kernel is broken.
  -# Download a 'vanilla' kernel, e.g. \c linux-<kernel-version>.tar.gz from
     http://www.kernel.org (e.g. http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.28.9.tar.bz2)
     to \c /usr/src
  -# Unpack the kernel
\code
$ cd /usr/src
$ tar xzvf linux-2.6.28.9.tar.bz2
$ mv linux-2.6.28.9 linux-2.6.28.9-rtai
$ ln -s linux-2.6.28.9-rtai linux
\endcode
Currently, for compiling the DynClamp plugin RELACS assumes that 
\c /usr/src/linux points to your rtai patched kernel.
-# Patch the kernel (use the patch file that matches the downloaded kernel)
\code
$ cd /usr/src/linux
$ patch -p1 < /usr/local/src/rtai/base/arch/x86/patches/hal-linux-2.6.28.9-x86-2.2-07.patch
\endcode
-# Configure, compile, and install the kernel.
Follow the intructions given in \ref installvanillakernel, starting at step 2.
On Debian, the make-kpkg command should be
\code
make-kpkg --initrd --append-to-version -rtai --revision 1 --config menuconfig kernel-image
\endcode
In the kernel configuration dialog you should do the following settings:
  - General setup: set "Local version" to -rtai (not needed if you are using \c make-kpkg)
  - Enable loadable module support: 
    - Select "Enable module support"
    - Deselect "Module versioning support"
  - Processor type and features: 
    - Deselect "Tickless System"
    - Select your "Subarchitecture Type" (PC-Compatible) - this option does not exist on newer kernels
    - Select the right Processor family (you find the name of your processor by looking at \c /proc/cpuinfo,
      check \c "help" to find out, which Processor family you have to select)
    - Select "Preemption Model (Preemptible kernel (Low-Latency Desktop))"
    - Set "Timer frequency" to 1000 Hz
XXX - disable kernel irq balancing (noirqbalance)
  - Power Management options:
    - Deselect "CPU Frequency scaling"
    .
  .
-# XXX Isolate CPUs If you have a multi-core system you should reserve at least one CPU for RTAI.
  isolcpus=0,1,2
  insmod rtai_hal.ko IsolCpusMask=0x07
-# Reboot into your new RTAI real time kernel.


\subsection rtaiinstall RTAI modules

-# Make sure that you are really running your RTAI kernel!
   You can check with
\code
$ uname -r
\endcode
-# Change to the RTAI directory
\code
$ cd /usr/local/src/rtai
\endcode
-# Configure RTAI by calling as root
\code
$ make menuconfig
\endcode
Check the following settings:
 - General
   - Installation directory: should be set t\o \c /usr/realtime
   - Linux source tree: must be set to \c /usr/src/linux
   - RTAI Documentation: select the documentation you want
   - Build RTAI testsuite: select
 - Machine
    - Number of CPUs: set to the rigth value. The default is often right.
      If in doubt, look into the file \c /proc/cpuinfo .
    - Enable FPU support: select
 - Base system
   - Other features
     - Mathfuns support in kernel: select
     - C99 standard support: select
 - Add-ons
   - Real Time COMEDI support in user space: leave unselected
 .
Then exit and save configuration.
Watch the output while RTAI is configured for possible warnings and errors.
In case this fails, you should check and/or edit the file \c .rtai_config
and run \c .configure manually.
-# Compile and install (as root)
\code
$ make && make install
\endcode
In case you get an error like "../../../base/include/asm/rtai_leds.h:24:20: error: asm/io.h: No such file or directory"
then delete the "#include <asm/io.h>" line in the specified file and call \c make again.
-# Make the RTAI kernel modules known to modprobe:
\code
$ ln -s /usr/realtime/modules /lib/modules/`uname -r`/rtai
$ depmod -a
\endcode
-# Test RTAI by loading the \c rtai_sched module:
\code
$ modprobe rtai_sched
\endcode
If this fails:
- add \c lapic to the kernel parameter in the \c kernel line of the
\c grub menu in \c /boot/grub/menu.lst .


\subsection rtaicomedi Comedi
For an RTAI kernel you definitely have to install the Comedi drivers 
yourself according to the following instructions:

-# Follow the instructions above for installing 
\ref installcomedidriver .
For configuring \c Comedi you should use
\code
$ ./configure --with-linuxdir=/usr/src/linux --with-rtaidir=/usr/realtime
\endcode
-# Check loading the \c Comedi module:
\code
$ modprobe comedi
\endcode
On failure, call 
\code
$ dmesg
\endcode
to get more details. If it says "unknown symbol", then you might have forgotten
to deselect the "Module versioning support" in the "loadable module support"
section of the kernel configuration. Either recompile your kernel with the 
"Module versioning support" deselected, or
\code
$ cp /lib/modules/`uname -r`/rtai/Module.symvers /usr/local/src/comedi/comedi
$ make clean
$ make && make install
$ depmod -a
$ cp /usr/local/src/comedi/comedi/Module.symvers /lib/modules/`uname -r`/comedi
\endcode
-# Then follow the instructions above for installing (if not already done, this is independent of the kernel used)
  - \ref installcomedilib
  - \ref installcomedicalib


\subsection testrelacs Test RELACS
-# If you haven't compiled RELACS yet, then follow the instructions in
the top-level \c INSTALL file (the final \c make \c install is not necessary for testing).
Otherwise, \c cd into the RELACS top-level directory and do (you do not have to be root for this,
except for loading the kernel modules in point 2)
\code
$ ./configure --with-rtai=/usr/realtime/include
$ cd plugins/linuxdevices/comedi
$ make clean
$ make
\endcode
-# Load the dynamic clamp kernel module (as root):
\code
$ cd plugins/linuxdevices/comedi/module
$ ./loadmodules.sh
\endcode
-# Run RELACS
\code
$ cd - # cd back into the top-level directory of RELACS
$ cd plugins/patchclamp
$ cp relacs.cfg.dynclamp relacs.cfg
$ ./relacslocal
\endcode
-# Possible problems are:
  - Data acquisition does not start:
    - You might not have 
      sufficient permissions for reading and writing to the 
      \c /dev/comedi* devices. For a quick fix do
      as root
      \code
$ chmod a+rw /dev/comedi*
      \endcode
      See \ref udev below for a better solution.
    - The %comedi and rtai modules are not properly loaded.
    - The %comedi device is not configured yet.
    .
  - Performance is bad / RELACS regularly hangs for a few seconds / RELACS seems to be slowed down dramatically.
    - Disable APM and ACPI by adding \c "apm=off" and \c acpi=off to the kernel parameter in the \c kernel line of the
      \c grub menu in \c /boot/grub/menu.lst .
    .
  .

\section udev Setting up udev permissions for Comedi device files

Once comedi is installed you also need to make sure that you (the
user) have appropriate permissions for accessing the comedi device
files. That is you need to be able to have read and write access to
the \c /dev/comedi* files. One elegant way to achieve this to create a
new group and tell udev to add the comedi device files to this group.

-# Login as root.
-# Create a new group "iocard":
\code
$ addgroup --system iocard
\endcode
-# Add udev rules to the /etc/udev/rules.d directory:
\code
$ echo 'KERNEL=="comedi*", MODE="0660", GROUP="iocard"' > /etc/udev/rules.d/95-comedi.rules
\endcode
-# Run
\code
$ udevadm trigger
\endcode
to apply your new udev rules
-# Add users to the "iocard" group:
\code
$ adduser <username> iocard
\endcode
After the next login, \c <username> is a member of the \c iocard group
and and has sufficient permissions to access the data acquisition boards through \c Comedi.


\section buffer Resize Comedi buffer

To set the \c Comedi internal buffers to 640kB do as root:
\code
$ comedi_config -r /dev/comedi0
$ comedi_config --read-buffer 640 --write-buffer 640 /dev/comedi0 ni_pcimio
\endcode
Maybe this should go in \c /etc/rc.local or to some \c udev postprocessing rule.


\section calibration Calibrating analog input and output

For software calibrated boards (like NI M-Series boards) do (as root?)
\code
$ comedi_soft_calibrate -f /dev/comedi0
\endcode
This calibrates all channels for all ranges.
A file is written to \c /usr/var/lib/comedi/calibrations that contains the calibration
parameter. The ComediAnalogInput and ComediAnalogOutput plugins read this file.

For calibrating all ranges, references, and channels of hardware calibrated
boards (e.g. NI E-Series) do
\code
$ for C in 0 $(seq 16); do
    for A in 0 1 2; do
      for R in 0 $(seq 20); do
        comedi_calibrate -reset -calibrate -f /dev/comedi0 -s 0 -r $R -a $A -c $C;
      done;
    done;
  done
$ for C in 0 1; do
    for A in 0 1 2; do
      for R in 0 1; do
        comedi_calibrate -reset -calibrate -f /dev/comedi0 -s 1 -r $R -a $A -c $C;
      done;
    done;
  done
\endcode


\section dynamicclamp Setting up dynamic clamp for RELACS
-# Tell the configure script of RELACS where RTAI is located.
For this, \c cd into the RELACS top-level directory and do
\code
$ ./configure --with-rtai=/usr/realtime/include
\endcode
-# Then compile the dynamic clamp plugins and the kernel module:
\code
$ cd plugins/linuxdevices/comedi
$ make clean
$ make
\endcode
-# Load the dynamic-clamp kernel module (as root):
\code
$ cd plugins/linuxdevices/comedi/module
$ ./loadmodules.sh
\endcode
-# If you want to load the dynamic-clamp kernel module automatically during 
the boot process, then call the \c loadmodules.sh script from the script
\c /etc/rc.local . Simply add a line like this
\code
/where/ever/the/script/is/located/loadmodules.sh
\endcode
to \c /etc/rc.local.

\section rtailinks Links
- http://www.comedi.org
- http://www.rtai.org
- http://wiki.linuxcnc.org/cgi-bin/emcinfo.pl?Debian_Lenny_Compile_RTAI
- http://www.captain.at/programming/kernel/
- http://www.lara.unb.br/~phsantana/data/files/technotes/HowTo_RTAI_Linux.pdf
- http://rt-fsm.googlecode.com/svn/trunk/INSTALL
- http://www.cyberciti.biz/faq/howto-install-kernel-headers-package/

*/
