/*!
\mainpage Comedi Relacs Plugins

\brief Interfaces to the Comedi data acquisition library for normal analog input and output as well as for dynamic clamp.


Comedi (linux control and measurement device interface) provides hardware drivers
to many data acquisition boards with a common library interface.
The RELACS Comedi plugins access data acquisition boards by means of the Comedi library.

For general information about Comedi and a list of supported devices
see http://www.comedi.org

\section comedicontent Content
- \ref comediintro
- \ref installcomedi
- \ref installrtai
- \ref udev
- \ref buffer
- \ref calibration
- \ref dynamicclamp
- \ref rtailinks


\section comediintro Introduction

If you only need normal ("streaming", asynchronous) data acquisition
as it is implemented by the ComediAnalogInput and ComediAnalogOutput plugins,
then follow the instructions in \ref installcomedi.

If you want to use dynamic clamp, i.e. some realtime computation,
as it is implemented by the DynClampAnalogInput and DynClampAnalogOutput plugins,
then you need to install a real-time linux kernel first, as described in
\ref installrtai.


\section installcomedi Install comedi

You should install the \c Comedi drivers and library prior to
configuring RELACS, so that ./configure can detect the presence of the
\c Comedi library.  Un recent linux distributions comedi is available
as a package (libcomedi-dev) and the kernel moduls are already in the
kernel. However, these are not the most recent version of comedi and
therefore you should reinstall the comedi drivers and the comedi
library from scratch as described in the following sections


\subsection installkernel Linux kernel

In order to be able to install the \c Comedi drivers you need to have a kernel source tree
that matches your running kernel image. Either compile your own kernel from scratch 
(section \ref installvanillakernel , takes some time),
or make sure that you get a matching source tree for your kernel image
(section \ref installkernelsources).


\subsubsection installkernelsources Install sources for an existing kernel

-# Get the soure that matches your kernel. 
On Ubuntu/Debian you get the kernel source and header files
matching your running kernel image by executing as root
\code
$ cd /usr/src
$ apt-get install dpkg-dev
$ apt-get source linux-image-`uname -r`
$ apt-get install linux-headers-`uname -r`
\endcode
If \c apt-get \c source tells you "E: You must put some 'source' URIs in your sources.list"
then you need to enable the source repositories for the package manager. For this
open with your favorite editor \c /etc/apt/sources.list and the \c *.list files in 
\c /etc/apt/sources.list.d/. Remove the comments in front of the lines
that start with \c "deb-src". Then run
\code
$ apt-get update
\endcode
to resynchronize the package index files with the new repositories. Now 
\c apt-get \c source should be able to download the kernel sources.
After downloading the kernel source create a link to the kernel source:
\code
ln -s linux <kernel-source>
\endcode
where \c <kernel-source> is the kernel source installed by \c apt-get.
Note that often the kernel source directory that you installed with \c apt-get
has a different name than the name of the currently running kernel that \c uname -r
returns. Use \c ls \c -rtl to list the directories in the \c /usr/src folder.
The last one is the one that was added by \c apt-get \c source.
Now you can \c cd into the kernel source directory
\code
$ cd linux
\endcode
-# Copy the kernel configuration file of your kernel image to the source:
\code
$ cp /boot/config-`uname -r` .config
\endcode
-# Make sure the file \c Module.symvers is also in your source. 
On Ubuntu/Debian you find it in the corresponding \c linux-headers directory:
\code
$ cp ../linux-headers-`uname -r`/Module.symvers .
\endcode
-# Run
\code
$ make oldconfig
$ make prepare
$ make scripts
\endcode

\subsubsection installvanillakernel Compile your own kernel

-# Get a vanilla kernel from http://www.kernel.org,
e.g. http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.38.8.tar.bz2,
place the tar file in \c /usr/src and unpack it as root with
\code
$ cd /usr/src
$ tar xjvf linux-2.6.38.8.tar.bz2
\endcode
(replace \c linux-2.6.38.8 by the directory name of your new kernel source).
Create a softlink to your kernel source 
\code
$ ln -s linux-2.6.38.8 linux
$ cd linux
\endcode
and make sure the \c make, \c gcc, \c libncurses-dev, and \c zlib1g-dev packages are installed:
\code
$ apt-get install make gcc libncurses-dev zlib1g-dev
\endcode
-# Reuse your current configuration (replace \c XXX by the name of your running kernel):
\code
$ cp /boot/config-XXX .config
$ make oldconfig
\endcode
Hit \c enter to all the (probably many) questions.
-# Steps 3. to 6. describe the normal way to compile a linux kernel.
On Debian systems there is an elegant alternative that is described
in step 9. below.
First, you configure your kernel by calling
\code
$ make menuconfig
\endcode
Possible settings you might want to change are:
  - Processor type and features: 
    - Select your Subarchitecture Type (PC-Compatible) - this option does not exist for newer kernels
    - Select the right Processor family (you find the name of your processor by looking at \c /proc/cpuinfo,
      check \c "help" to find out, which Processor family you have to select)
    - Select "Preemption Model (Preemptible kernel (Low-Latency Desktop))"
  .
Leave the configuration dialog by pressing "Exit" until you are asked "Save kernel config?".
Select "Yes".
-# Then compile and install (as root) the kernel
\code
$ make && make modules && make modules_install && make install
\endcode
This takes quite a while.
-# Finally you might need to create a RAM disk image file,
if \c make \c install did not create a \c /boot/initrd-2.6.38.8 file already:
\code
$ cd /boot
$ update-initramfs -c -k 2.6.38.8
\endcode
-# Check the grub menu whether your new kernel was added. 
  - With \c grub \c v2 (default since Debian Lenny) simply run
    \code
$ update-grub
\endcode
    the output of \c update-grub should mention your new kernel image.
    You can configure \c grub \c v2 by editing the file \c /etc/default/grub .
    To get the boot menu that you need to select the kernel you want to boot
    you should for example unset the \c GRUB_HIDDEN_TIMEOUT and set the
    \c GRUB_TIMEOUT appropriately in that file. For example:
    \code
#GRUB_HIDDEN_TIMEOUT=0
#GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=10
\endcode
    Also, if ou do not like that grub puts your rtai kernel into a subsection called
    'Previous linux versions', then comment out the following lines in \c /etc/grub.d/10_linux
    \code
#  if [ "$list" ] && ! $in_submenu; then
#    echo "submenu \"Previous Linux versions\" {"
#    in_submenu=:
#  fi
\endcode
    After editing run \c update-grub to apply the changes.
  - With \c grub \c v1 (default up-to Debian Lenny) 
    there should be an entry like this in \c /boot/grub/menu.lst:
    \code
title           Debian GNU/Linux, kernel 2.6.28.9
root            (hd0,0)
kernel          /boot/vmlinuz-2.6.28.9 root=/dev/sda1 ro quiet
initrd          /boot/initrd.img-2.6.28.9
\endcode
  .
-# Reboot the computer into the new kernel.
\code
$ reboot
\endcode
-# Install third party kernel modules as well,
like for example the ones for your graphics board.
For your nvidia graphics board, download the driver from
http://www.nvidia.com/Download/index.aspx?lang=en-us.
Install it by calling
\code
$ sh NVIDIA-Linux-x86_64-190.42-pkg2.run
\endcode
If you want to install the nvidia driver for a second kernel, then call
\code
$ sh NVIDIA-Linux-x86_64-190.42-pkg2.run -k 2.6.28.9-rtai -K
\endcode
(replace 2.6.28.9-rtai by the name of the kernel where you want to install the nvidia driver,
i.e. the string '\c uname \c -r' would return if that kernel is running).
-# On a Debian system there is an alternative to steps 3. - 6. for compiling a linux kernel. 
   See http://wiki.linuxcnc.org/cgi-bin/wiki.pl?Debian_Lenny_Compile_RTAI for more details.
   Do as root:
   -# Get the kernel-package
   \code
$ apt-get install kernel-package libncurses-dev
   \endcode
   -# Configure and build the kernel:
   \code
$ export CONCURRENCY_LEVEL=2  # set here the number of CPUs you have to speed things up!
$ make-kpkg clean
$ make-kpkg --initrd --revision 1.0 --config menuconfig kernel-image kernel-headers kernel-source
   \endcode
   You can also supply a \c -j option to tell make how many processes can be run in parallel.
   See step 3. for hints on the configuration options.
   -# Install the kernel
   \code
$ cd ..
$ dpkg -i linux-image-2.6.38.8_1.0_amd64.deb linux-headers-2.6.38.8_1.0_amd64.deb
   \endcode
   -# continue with step 6.


\subsection installcomedidriver Comedi

Kernel versions 2.6.30 onwards have an experimental in-tree Comedi
implementation in the driver "staging" area. You can check whether it
works for you by following the instructions of point 11 below.  
However, we recommend installing a current version of the comedi drivers.

Here are all commands that you can throw into a shell to completely install comedi.
Before you do this, you have to make sure that all required packages are installed:
\code
apt-get install git autoconf libtool bison flex libgsl0-dev libboost-program-options-dev
\endcode
Now you go:
\code
# download comedi sources:
cd /usr/local/src
git clone git://comedi.org/git/comedi/comedi.git
git clone git://comedi.org/git/comedi/comedilib.git
git clone git://comedi.org/git/comedi/comedi_calibrate.git
rm -r /lib/modules/`uname -r`/kernel/drivers/staging/comedi

# comedi:
cd /usr/local/src/comedi
./autogen.sh
./configure
make && make install
depmod -a
cp include/linux/comedi.h /usr/include/linux/
cp include/linux/comedilib.h /usr/include/linux/

# comedilib:
cd /usr/local/src/comedilib
./autogen.sh
./configure --prefix=/usr --sysconfdir=/etc
make && make install

# comedi_calibrate:
cd /usr/local/src/comedi_calibrate
autoreconf -v -i
./configure --prefix=/usr --sysconfdir=/etc
make && make install

# setup udev permissions:
addgroup --system iocard
echo 'KERNEL=="comedi*", MODE="0660", GROUP="iocard"' > /etc/udev/rules.d/95-comedi.rules
udevadm trigger
adduser $USER iocard
\endcode
In the following the necessary steps are described in detail:

-# Download the current \c Comedi sources from the Git repository to \c /usr/local/src
as root.
\code
$ cd /usr/local/src
$ git clone git://comedi.org/git/comedi/comedi.git
$ git clone git://comedi.org/git/comedi/comedilib.git
$ git clone git://comedi.org/git/comedi/comedi_calibrate.git
\endcode
Or download the current	Git snapshots from http://www.comedi.org/download.html 
to \c /usr/local/src and unpack them
\code
$ cd /usr/local/src
$ tar xzvf comedi-HEAD-*.tar.gz
$ tar xzvf comedilib-HEAD-*.tar.gz
$ tar xzvf comedi_calibrate-HEAD-*.tar.gz
\endcode
-# You may need to install the packages: \c autoconf, \c libtool.
\code
$ apt-get install autoconf libtool
\endcode
-# Make sure that you are really running the kernel
  for which you want to install \c Comedi!
  You can check with
\code
$ uname -r
\endcode
-# Remove the Comedi staging modules to avoid conflicts:
\code
$ rm -r /lib/modules/`uname -r`/kernel/drivers/staging/comedi
\endcode
-# Change to the \c Comedi directory:
\code
$ cd /usr/local/src/comedi
\endcode
-# Generate the configuration script by calling
\code
$ ./autogen.sh
\endcode
You may ignore warnings and reminders.
-# Configure simply by calling
\code
./configure
\endcode
in case you want to install \c Comedi into your currently running kernel.
If \c /usr/src/linux is not your running kernel, then call
\code
$ ./configure --with-linuxsrcdir=/usr/src/linux
\endcode
with \c /usr/src/linux replaced by the path to the sources of the kernel
for which you want to install \c Comedi.
-# Compile
\code
$ make
\endcode
and install (as root)
\code
$ make install
$ depmod -a
\endcode
-# For some strange reason, the include files for kcomedilib \c linux/comedilib.h and 
\c linux/comedi.h are not installed by \c Comedi to \c [prefix]/include/linux .
These files are needed for compiling the kernel modules that use Comedi.
Also, RTAI expects \c Comedi include files in \c [prefix]/include/linux.
Therefore you need to copy the \c Comedi include files 
to \c [prefix]/include/linux yourself:
\code
$ cp include/linux/comedi.h /usr/include/linux/
$ cp include/linux/comedilib.h /usr/include/linux/
\endcode
-# Check loading the Comedi module:
\code
$ modprobe comedi
\endcode
If you do not get any error message, then the Comedi kernel modules were
successfully compiled and can be loaded into the kernel.
-# Check autodetection of your data acquisition board:
\code
$ udevadm trigger
$ ls /dev/comedi*
\endcode
In case the \c ls command shows something like
\code
/dev/comedi0        /dev/comedi0_subd1   /dev/comedi0_subd12
/dev/comedi0_subd0  /dev/comedi0_subd11  /dev/comedi0_subd2
\endcode
i.e. some \c comedi* character device files, your board probably was detected. Run
\code
$ comedi_board_info /dev/comedi0
\endcode
(or comedi_test -t info -f /dev/comedi0) to see more details about your data acquisition board 
(note: both \c comedi_board_info and \c comedi_test are part of comedilib, see below).
In case no \c /dev/comedi* device file shows up
or \c comedi_test reported an error (E: comedi_open("/dev/comedi0"): No such device),
your data acquisition board needs to be configured manually, using something like
\code
$ comedi_config /dev/comedi0 ni_mio_cs
\endcode
that can be put into the \c /etc/init.d/boot.local file, so that
the board is configured during startup of the system.
Read the man page of \c comedi_config first!
\code
$ man comedi_config
\endcode


\subsection installcomedilib Comedilib
-# You may need to install the packages: \c autoconf, \c libtool, \c bison, \c flex.
\code
$ apt-get install bison flex
\endcode
-# Change to the \c comedilib directory as root:
\code
$ cd /usr/local/src/comedilib
\endcode
-# Generate the configuration script by calling
\code
$ ./autogen.sh
\endcode
You may ignore warnings and reminders.
-# Configure comedilib to be installed in \c /usr/lib and \c /usr/include
\code
$ ./configure --prefix=/usr --sysconfdir=/etc
\endcode
If you want to have Comedlib to be installed somewhere else, specify another \c prefix.
You may want to read \c ./configure \c --help as well.
Pay attention to warnings and errors! You might need to install additional software first.
-# Compile and install (as root)
\code
$ make && make install
\endcode
-# In case \c make fails with this error message:
\code
libtool: link: gcc -std=gnu99 -I../include -I../include -Wall -g -O2 -o .libs/comedi_test comedi_test-bufconfig.o comedi_test-cmd_1.o comedi_test-cmd_2.o comedi_test-cmd_3.o comedi_test-info.o comedi_test-insn_read.o comedi_test-insn_read_time.o comedi_test-inttrig.o comedi_test-lib.o comedi_test-main.o comedi_test-mmap.o comedi_test-mode0_read.o comedi_test-select.o  ../lib/.libs/libcomedi.so -lm
../lib/.libs/libcomedi.so: undefined reference to `nearbyint'
../lib/.libs/libcomedi.so: undefined reference to `floor'
collect2: error: ld returned 1 exit status
make[2]: *** [comedi_test] Error 1
make[2]: Leaving directory `/usr/local/src/comedilib/testing'
make[1]: *** [all-recursive] Error 1
make[1]: Leaving directory `/usr/local/src/comedilib'
make: *** [all] Error 2
\endcode
then add the following line
\code
libcomedi_la_LIBADD = -lm
\endcode
to \c lib/Makefile.am after the line \c libcomedi_la_LDFLAGS. Then run
\code
$ make clean
$ ./autogen.sh
$ ./configure --prefix=/usr --sysconfdir=/etc
$ make && make install
\endcode


\subsection installcomedicalib Comedi_calibrate
-# You may need to install the packages:  \c autoconf, \c libtool, 
   \c libgsl0-dev, \c libboost-program-options-dev.
\code
$ apt-get install libgsl0-dev libboost-program-options-dev
\endcode
-# Change to the \c comedi_calibrate directory as root:
\code
$ cd /usr/local/src/comedi_calibrate
\endcode
-# Generate the configuration script by calling
\code
$ autoreconf -v -i
\endcode
You may ignore warnings and reminders.
-# Configure
\code
$ ./configure --prefix=/usr --sysconfdir=/etc
\endcode
-# Compile and install (as root)
\code
$ make && make install
\endcode


\section installrtai Install RTAI and Comedi

For dynamic clamp you need an RTAI patched linux kernel and Comedi.

\note (June 2013) There is a problem regarding newer versions of clib
(version >= 2.15, version 2.13 works, check version with \c ldd \c
--version). The \c rtai_math module does not compile correctly with
the newer libc version. I have not figured out a nice solution to this
bug other than to use a not so new linux distro.... Working is
linux Mint upto version 12 (Lisa), Ubuntu Oneiric, Debian Linux 7.0.
Find out your distro with \c cat \c /etc/issue or \c lsb_release \c -a.

\subsection rtaikernel Linux kernel and RTAI patch

-# Download the latest RTAI (http://www.rtai.org) version 
(the following instructions where tested successfully with version 3.9) from
the RTAI repository at http://www.rtai.org/RTAI
and put it into \c /usr/local/src as root.
Alternatively you could try to clone the source from \c https://github.com/ShabbyX/RTAI.
This version fixed quite some autotools issues and
is working hard on getting the rtai_math module back.
Unfortunately, this also failed so far (February 2014, Linux Mint 16 Petra, kernel 3.8.13)
-# Unpack RTAI in /usr/local/src:
\code
$ cd /usr/local/src
$ tar xjvf rtai-3.9.tar.bz2
$ ln -s rtai-3.9 rtai
\endcode
-# Check for available patches. Get a list of all patches for all architectures:
\code
$ find rtai/base/arch/ -name '*.patch' | sort
\endcode
The most recent patches for intel and amd 32 and 64-bit systems are in the x86 directory.
Decide for a patch, and remember its version number: \c hal-linux-<kernel-version>-*.patch
  -# I got the 2.6.38.8 to work.
  -# Too old (usually not so old) kernels do not compile with the curent version of the \c gcc compiler.
  -# Download a 'vanilla' kernel, e.g. \c linux-<kernel-version>.tar.gz from
     http://www.kernel.org (e.g. http://www.kernel.org/pub/linux/kernel/v2.6/linux-2.6.38.8.tar.bz2)
     to \c /usr/src
  -# Unpack the kernel
\code
$ cd /usr/src
$ tar xjvf linux-2.6.38.8.tar.bz2
$ mv linux-2.6.38.8 linux-2.6.38.8-rtai
$ ln -s linux-2.6.38.8-rtai linux
\endcode
Currently, for compiling the DynClamp plugin RELACS assumes that 
\c /usr/src/linux points to your rtai patched kernel.
-# Patch the kernel (use the patch file that matches the downloaded kernel)
\code
$ cd /usr/src/linux
$ patch -p1 < /usr/local/src/rtai/base/arch/x86/patches/hal-linux-2.6.38.8-x86-2.11-02.patch
\endcode
-# Configure, compile, and install the kernel.
\note In newer gcc and kernels there is a problem with some compiler
flag when compiling the RTAI math module.  Disable (comment them out
using '#') in \c /usr/src/linux/arch/x86/Makefile all lines with \c
-mpreferred-stack-boundary=3 before configuring and compiling the
kernel.

Follow the intructions given in \ref installvanillakernel, starting at step 2.
On Debian, the make-kpkg command should be
\code
$ make-kpkg --initrd --append-to-version -rtai --revision 1.0 --config menuconfig kernel-image kernel-headers kernel-source
\endcode
In the kernel configuration dialog you should do the following settings:
  - General setup: set "Local version" to -rtai (not needed if you are using \c make-kpkg)
  - Enable loadable module support: 
    - Select "Enable module support"
    - Deselect "Module versioning support"
  - Processor type and features: 
    - Disable "Tickless System"
    - Select your "Subarchitecture Type" (PC-Compatible) - this option does not exist for newer kernels
    - Select the right Processor family (you find the name of your processor by looking at \c /proc/cpuinfo,
      check \c "help" to find out, which Processor family you have to select)
    - Select "Preemption Model (Preemptible kernel (Low-Latency Desktop))"
    - Disable “Use register arguments” - this option does not exist for newer kernels (version <= 2.6.19)
    - Select "Interrupt pipeline"
    - Set "Timer frequency" to 1000 Hz
  - Power management and ACPI options:
    - Disable "CPU Frequency scaling"
    .
  .
-# Reboot into your new RTAI real time kernel.
If this fails:
Try adding one or several of the advanced configuration and power interface (ACPI) or 
advanced programmable interrupt controller (APIC) options,
\c acpi=off \c pci=noacpi \c noapic \c nolapic \c lapic ,
to the kernel parameter in the \c kernel line of the
\c grub menu in \c /boot/grub/menu.lst (\c grub \c v1) or to the \c GRUB_CMDLINE_LINUX variable
in \c /etc/defaults/grub . 
After restart, check for the number of CPUs in \c /proc/cpuinfo - they might be reduced by these parameters!


\subsection rtaiinstall RTAI modules

-# Make sure that you are really running your RTAI kernel!
   You can check with
\code
$ uname -r
\endcode
-# Change to the RTAI directory
\code
$ cd /usr/local/src/rtai
\endcode
-# In case you downloaded RTAI from https://github.com/ShabbyX/RTAI,
you need to generate configure script and makefiles first:
\code
$ ./autogen.sh
\endcode
(do not call ./autogen.sh when using the original RTAI sources since it might fail).
-# Configure RTAI by calling as root
\code
$ make menuconfig
\endcode
Check the following settings:
 - General
   - Installation directory: should be set to \c /usr/realtime
   - Linux source tree: must be set to \c /usr/src/linux
   - RTAI Documentation: deselect all documentation (if you don't you might get an error)
   - Build RTAI testsuite: select
 - Machine
    - Number of CPUs: set to the right value. The default is not always right.
      If in doubt, look into the file \c /proc/cpuinfo .
    - Enable FPU support: select
 - Base system
   - Other features
     - Mathfuns support in kernel: select
     - C99 standard support: select
 - Add-ons
   - Real Time COMEDI support in user space: leave unselected
 .
Then exit and save configuration.
Watch the output while RTAI is configured for possible warnings and errors.
In case this fails, you should check and/or edit the file \c .rtai_config
and run \c .configure manually.
-# Compile and install (as root)
\code
$ make && make install
\endcode
Known issues:
  - In case you get an error like "/usr/include/features.h:323:26: fatal error: bits/predefs.h: No such file or directory" install the gcc-multilib package
  \code
$ apt-get install gcc-multilib
\endcode
  - In case you get an error like "../../../base/include/asm/rtai_leds.h:24:20: error: asm/io.h: No such file or directory"
  then delete the "#include <asm/io.h>" line in the specified file and call \c make again.
  - If you get error messages like 
    "../../../base/sched/liblxrt/.libs/liblxrt.so: undefined reference to `pthread_create'",
    i.e. undefined references to various pthread functions,
    then open \c base/sched/liblxrt/GNUmakefile in you favourite editor,
    find the line containing 'liblxrt_la_LIBADD' and add "-lpthread" to it so that this line looks like
    \code
liblxrt_la_LIBADD = -lpthread
\endcode
    Then
    \code
$ cd base/sched/liblxrt
$ make clean
$ cd -
$ make
\endcode
  .
-# Make the RTAI kernel modules known to modprobe:
\code
$ ln -s /usr/realtime/modules /lib/modules/`uname -r`/rtai
$ depmod -a
\endcode
-# Test RTAI by loading the \c rtai_sched module:
\code
$ modprobe rtai_sched
\endcode
If this fails:
Try adding one or several of the advanced configuration and power interface (ACPI) or 
advanced programmable interrupt controller (APIC) options,
\c acpi=off \c pci=noacpi \c noapic \c nolapic \c lapic ,
to the kernel parameter in the \c kernel line of the
\c grub menu in \c /boot/grub/menu.lst (\c grub \c v1) or to the \c GRUB_CMDLINE_LINUX variable
in \c /etc/defaults/grub . 
Recompile and install RTAI (make clean && make && make install && depmod -a).
After restart, check for the number of CPUs in \c /proc/cpuinfo - they might be reduced by these parameters!
-# If you have a multi-core system you should reserve at least one CPU for RTAI. You can isolate CPUs by using    the kernel parameter
   \code
isolcpus=0,1,2
   \endcode
  (for isolating the cores no. 0, 1, and 2) and by loading the rtai_hal kernel module the following way:
  \code
insmod rtai_hal.ko IsolCpusMask=0x07
  \endcode
  See the file \c /usr/local/src/rtai/README.ISOLCPUS for more details.
-# Run the RTAI latency test
\code
$ cd /usr/realtime/testsuite/kern/latency
$ run
\endcode


\subsection rtaicomedi Comedi
For an RTAI kernel you definitely have to install the Comedi drivers 
yourself according to the following instructions:

-# Follow the instructions above for installing 
\ref installcomedidriver .
For configuring \c Comedi you should use
\code
$ ./configure --with-linuxdir=/usr/src/linux --with-rtaidir=/usr/realtime
\endcode
-# Check loading the \c Comedi module:
\code
$ modprobe comedi
\endcode
On failure, call 
\code
$ dmesg
\endcode
to get more details. If it says "unknown symbol", then you might have forgotten
to deselect the "Module versioning support" in the "loadable module support"
section of the kernel configuration. Either recompile your kernel with the 
"Module versioning support" deselected, or
\code
$ cp /lib/modules/`uname -r`/rtai/Module.symvers /usr/local/src/comedi/comedi
$ make clean
$ make && make install
$ depmod -a
$ cp /usr/local/src/comedi/comedi/Module.symvers /lib/modules/`uname -r`/comedi
\endcode
-# Then follow the instructions above for installing (if not already done, this is independent of the kernel used)
  - \ref installcomedilib
  - \ref installcomedicalib


\subsection testrelacs Test RELACS
-# If you haven't compiled RELACS yet, then follow the instructions in
the top-level \c INSTALL file (the final \c make \c install is not necessary for testing).
Otherwise, \c cd into the RELACS top-level directory and do (you do not have to be root for this,
except for loading the kernel modules in point 2)
\code
$ ./configure
$ cd plugins/linuxdevices/comedi
$ make clean
$ make
\endcode
-# Load the dynamic clamp kernel module (as root):
\code
$ cd plugins/linuxdevices/comedi/module
$ ./loadmodules.sh
\endcode
-# Run RELACS
\code
$ cd - # cd back into the top-level directory of RELACS
$ cd plugins/patchclamp
$ cp relacs.cfg.dynclamp relacs.cfg
$ ./relacslocal
\endcode
-# Possible problems are:
  - Data acquisition does not start:
    - You might not have 
      sufficient permissions for reading and writing to the 
      \c /dev/comedi* devices. For a quick fix do
      as root
      \code
$ chmod a+rw /dev/comedi*
      \endcode
      See \ref udev below for a better solution.
    - The %comedi and rtai modules are not properly loaded.
    - The %comedi device is not configured yet.
    .
  - Performance is bad / RELACS regularly hangs for a few seconds / RELACS seems to be slowed down dramatically.
    - Disable APM and ACPI by adding \c "apm=off" and \c acpi=off to the kernel parameter in the \c kernel line of the
      \c grub menu in \c /boot/grub/menu.lst .
    .
  .

\section udev Setting up udev permissions for Comedi device files

Once comedi is installed you also need to make sure that you (the
user) have appropriate permissions for accessing the comedi device
files. That is you need to be able to have read and write access to
the \c /dev/comedi* files. One elegant way to achieve this to create a
new group and tell udev to add the comedi device files to this group.

-# Login as root.
-# Create a new group "iocard":
\code
$ addgroup --system iocard
\endcode
-# Add udev rules to the /etc/udev/rules.d directory:
\code
$ echo 'KERNEL=="comedi*", MODE="0660", GROUP="iocard"' > /etc/udev/rules.d/95-comedi.rules
\endcode
-# Run
\code
$ udevadm trigger
\endcode
to apply your new udev rules
-# Add users to the "iocard" group:
\code
$ adduser \<username\> iocard
\endcode
After the next login, \c \<username\> is a member of the \c iocard group
and and has sufficient permissions to access the data acquisition boards through \c Comedi.


\section buffer Resize Comedi buffer

To set the \c Comedi internal buffers to 640kB do as root:
\code
$ comedi_config -r /dev/comedi0
$ comedi_config --read-buffer 640 --write-buffer 640 /dev/comedi0 ni_pcimio
\endcode
Maybe this should go in \c /etc/rc.local or to some \c udev postprocessing rule.


\section calibration Calibrating analog input and output
For calibrating analog input and output you should run \c comedi_calibrate 
once in a while.
\c comedi_calibrate writes a file to \c /usr/var/lib/comedi/calibrations that contains the calibration
parameter. The ComediAnalogInput and ComediAnalogOutput plugins read this file and apply the
calibration.

For hardware calibrated boards (like NI E-Series boards) do
\code
$ comedi_calibrate --reset --calibrate -f /dev/comedi0
\endcode

For software calibrated boards (like NI M-Series boards) do
\code
$ comedi_soft_calibrate -f /dev/comedi0
\endcode

You may want to read the man page of \c comedi_calibrate.


\section dynamicclamp Setting up dynamic clamp for RELACS
-# \c cd into the RELACS top-level directory and run
\code
$ ./configure
\endcode
This should detect RTAI (see message towards the end of the output of \c configure).
-# Then compile the dynamic clamp plugins and the kernel module:
\code
$ cd plugins/linuxdevices/comedi
$ make clean
$ make
\endcode
-# Load the dynamic-clamp kernel module (as root):
\code
$ cd plugins/linuxdevices/comedi/module
$ ./loadmodules.sh
\endcode
-# If you want to load the dynamic-clamp kernel module automatically during 
the boot process, then call the \c loadmodules.sh script from the script
\c /etc/rc.local . Simply add a line like this
\code
/where/ever/the/script/is/located/loadmodules.sh
\endcode
to \c /etc/rc.local.

\section rtailinks Links
- http://www.comedi.org
- http://www.rtai.org
- http://wiki.linuxcnc.org/cgi-bin/emcinfo.pl?Debian_Lenny_Compile_RTAI
- http://www.captain.at/programming/kernel/
- http://www.lara.unb.br/~phsantana/data/files/technotes/HowTo_RTAI_Linux.pdf
- http://rt-fsm.googlecode.com/svn/trunk/INSTALL
- http://www.cyberciti.biz/faq/howto-install-kernel-headers-package/

*/
