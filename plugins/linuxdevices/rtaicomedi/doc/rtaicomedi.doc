/*!
\mainpage RTAI-comedi Relacs Plugins

\brief Plugins for dynamic clamp based on RTAI and comedi.

\section rtaicomedicontent Content
- \ref rtaicomediintro
- \ref quickinstall
- \ref basickernelconfiguration
- \ref testrtai
- \ref configurekernel
- \ref installrelacs
- \ref configdynamicclamp
- \ref simulatedynclamp

\section rtaicomediintro Introduction

For using dynamic clamp, i.e. some realtime computation, as it is
implemented by the DynClampAnalogInput and DynClampAnalogOutput
plugins, you need to install an RTAI-patched real-time linux
kernel, RTAI kernel modules, and comedi device drivers.

RELACS provides a script that helps you in the installation process.
This is described in the following section \ref quickinstall. The
script should work on debian based systems, but is has not been tested
on other Linux distributions.

Alternatively, you can do the installation manually as explained in
\ref manualinstall .

In either case, continue with building the dynamic clamp module of
RELACS as explained in \ref installrelacs and configuring RELACS
as explained in \ref configdynamicclamp .

If you only want to simulate a dynamic clamp, then skip all
installation procedures and just read \ref simulatedynclamp .


\section quickinstall Install an RTAI-patched linux kernel, RTAI, and comedi

The \c makertaikernel.sh script in \c
plugins/linuxdevices/rtaicomedi/scripts/ executes all the commands
needed to download and build an RTAI-patched linux kernel, the newlib
library (needed for math support), and the RTAI and comedi kernel
modules. 

The script is so far only used and tested on debian based systems and
is likely to fail on other Linux distributions. Feel free to adapt the
script to your Linux distribution.

-# From the relacs source tree go to
   \code
cd plugins/linuxdevices/rtaicomedi/scripts
   \endcode

-# Select an RTAI source (-r option or RTAI_DIR variable, see \c
   ./makertaikernel.sh \c help for options, usually the default should be fine) and run
   \code
sudo ./makertaikernel.sh init
   \endcode
   to make sure you have \c /var/log/messages (needed for RTAI switch
   tests), you get a visible boot menu, have comedi devices assigned
   to the \c iocard group, and have the RTAI sources downloaded.

   This command ends with showing you the RTAI kernel patches
   available for your machine.

-# Select a Linux kernel and the corresponding RTAI patch from the displayed list.

   Modify the variables at the top of the \c makertaikernel.sh script
   or set them before executing makertaikernel.sh, in particular the
   \c LINUX_KERNEL, \c RTAI_PATCH, and \c KERNEL_PATH variables to
   match the kernel version, rtai patch you want to use, and the
   directory where to build the linux kernel (you need up to 2 GB
   space there for a kernel with most device drivers disabled
   (e.g. via localmodconf) or 5-10GB for a full kernel).

   Recheck for available RTAI patches and linux kernels:
   \code
sudo ./makertaikernel.sh info rtai
   \endcode

-# You should start out with a kernel
   configuration of a kernel image from your linux distribution
   closest to the kernel version you selected. On a Debian-based
   system install a matching kernel by executing
   \code
sudo apt-get install linux-image-4.4.0-79
   \endcode
   (modify it to the kernel version you want, use the tab-key for
   autocompletion) and boot into this kernel. Either restart your computer
   and select the kernel from the grub boot menu or check the grub menu with
   \code
sudo ./makertaikernel.sh info grub
   \endcode
   and reboot using
   \code
sudo ./makertaikernel.sh reboot 3
   \endcode
   replace '3' by the index of the appropriate menu entry. The latter
   has the advantage that it doesn't matter to miss the boot menu.

   Starting out with a kernel matching the one from the selected RTAI
   patch ensures that makertaikernel.sh will use this kernel's
   configuration and deselect all kernel modules that are not used
   (localmodconfig). This dramatically shortens the compile time.

   If you use \c makertaikernel.sh with the \c -l switch or the
   version of the running kernel does not match the one of the
   selected kernel (major or minor version number differ),
   localmodconfig is not applied, resulting in a much larger kernel
   (takes much more time to compile).

-# Once you booted into the kernel on which you want to base your RTAI
   kernel run
   \code
sudo ./makertaikernel.sh
   \endcode

   This will download the required sources (takes a while...) and
   build the kernel using the kernel configuration of the running
   kernel (takes even more time...). 

   With the `-c` flag you can provide a different kernel configuration
   on which the kernel configuration should be based (see \c
   makertaikernel.sh \c help for details).

-# You will get the menu for configuring the kernel. This is the most
   important step! See \ref basickernelconfiguration for instructions.

-# Reboot into the new kernel by executing
   \code
sudo ./makertaikernel.sh reboot
   \endcode

-# Once you booted into the RTAI kernel run some tests by invoking
   \code
sudo ./makertaikernel.sh test
   \endcode
   to run the "kern" tests.
   See 
   \code
sudo ./makertaikernel.sh test help
   \endcode
   for possible options of the test action.
   For example, run the tests without user interaction for 30 seconds and name
   the test results "basic":
   \code
sudo ./makertaikernel.sh test 30 auto basic
   \endcode

   The result of the tests is written into the file
   \c latencies-KERNEL-RTAI-HOST-NNN-DATE-NAME-QUALITY and the
   corresponding kernel configuration is saved in
   \c config-KERNEL-RTAI-HOST-NNN-DATE-NAME_QUALITY in the current
   directory. KERNEL is replaced by the kernel version, RTAI by your
   choice of an RTAI source (e.g. magma, rtai-5.1, etc.), HOST is the
   hostname of your machine, NNN is replaced by a consecutive number,
   DATE is the current date, NAME and QUALITY are short strings
   describing your kernel configuration and the test performance that
   is retrieved from the latency test.

   See \ref testrtai for details regarding the test results and \ref configurekernel
   for troubleshooting and how to improve the real time performance.

-# If you did not start out with a kernel version matching the version
   of your RTAI-patched kernel, then before you go on with improving
   the kernel configuration run
   \code
sudo ./makertaikernel.sh -c mod
   \endcode
   in order to deselect all unused kernel modules from compilation. 
   This speeds up the following kernel builds dramatically! Then reboot and test.

-# If the test results do not satisfy you, then build a new version of
   the kernel with a different configuration (see \ref configurekernel
   for details) and a different name (\c -n option). The name can be
   any string without whitespace - a simple number or a string
   describing the configuration of the kernel:
   \code
sudo ./makertaikernel.sh -n 2 reconfigure
   \endcode
   reboot into the new kernel, test the new kernel, reconfigure again yet another kernel (with a different name):
   \code
sudo ./makertaikernel.sh -n 2 reboot
...
sudo ./makertaikernel.sh -n 2 test
sudo ./makertaikernel.sh -n 1 reconfigure
   \endcode
   reboot, and do the same with the right kernel names:
   \code
sudo ./makertaikernel.sh -n 1 test
sudo ./makertaikernel.sh -n 2 reconfigure
   \endcode

   Note that \c makertaikernel.sh \c reconfigure will first uninstall
   an already existing kernel with the same name (this is why we need
   to work with at least two different kernel names).

   You can recreate this kernel or use this kernel's configuration for
   further modifications by specifying the kernel configuration file
   saved by \c makertaikernel.sh \c test using the `-c` option
   \code
sudo ./makertaikernel.sh -n 1 -c config-3.14.17-rtai-4.1-002-basic-good reconfigure
   \endcode
-# Once you are satisified, continue with \ref installrelacs .

For further options of the \c makertaikernel.sh script see
\code
./makertaikernel.sh help
\endcode
To show some information about your machine, RTAI patches, grub menue, etc. run
\code
./makertaikernel.sh info
\endcode


\section basickernelconfiguration Kernel configuration
For making the Linux kernel work with RTAI you should check the following settings 
in the kernel configuration dialog.

Also read /usr/local/src/rtai/README.CONF_RMRKS !

- "General setup":
  - Disable "Enable sytem-call auditing support" (\c AUDITSYSCALL)
  - Important: set "Stack Protector buffer overflow detection" (at the bottom of the menu) to
    "Regular" (\c CC_STACKPROTECTOR_REGULAR)  - 
    or even "None" (\c CC_STACKPROTECTOR_NONE) if the latency test crashes.
  .
- "Power management and ACPI options":
  - In "ACPI (Advanced Configuration and Power Interface) Support":
    - Disable "Processor" (\c ACPI_PROCESSOR)
    .
  - Disable "CPU Frequency scaling" (\c CPU_FREQ)
  - In "CPU Idle":
    - Disable "CPU idle PM support" (\c CPU_IDLE)
    .
  .
- "Device Drivers":
  - In "Staging drivers":
    - Deselect "Data acquisition support (comedi)" (\c COMEDI)
      (Really? It comes with kcomedilib!)
    .
  .
- "Kernel hacking": 
  - In "Compile-time checks and compiler options":
    - Disable "Compile the kernel with debug info" (\c DEBUG_INFO)
    .
    Disabling debugging information makes the kernel much
    smaller. So unless you know that you need it disable it.
  - Disable "Tracers" (\c FTRACE)
  .
.
Leave the configuration dialog by pressing "Exit" until you are asked "Save kernel config?".
Select "Yes".

Then the new kernel is being compiled - be patient.


\section testrtai Testing performance of RTAI kernel

Testing your RTAI patched kernel is crucial for a good real-time performance!

-# The \c makertaikernel.sh can also be used for testing with the advantage that it writes
   the test results and the kernel configuration into files.

   The script will first ask for a short description of your kernel
   configuration and parameter. This string is then used for naming
   the files for the test results.

-# Test RTAI by loading some modules:
   \code
cd /usr/realtime/modules
insmod rtai_hal.ko
insmod rtai_sched.ko
insmod rtai_math.ko
   \endcode

   This is done by
   \code
sudo ./makertaikernel.sh test none
   \endcode
If you only want to check insmodding \c rtai_hal then call
   \code
sudo ./makertaikernel.sh test hal none
   \endcode
Equivalently, you can use the \c sched and \c math option.

   If this fails:

   First, check the output of
   \code
dmesg
   \endcode
   for some hints.

   Try adding one or several of the advanced configuration and power
   interface (ACPI) or advanced programmable interrupt controller
   (APIC) options, \c acpi=off, \c pci=noacpi, \c noapic, \c nolapic,
   or \c lapic, to the kernel parameter.

   Either provide the kernel parameter to \c makertaikernel.sh:
   \code
sudo ./makertaikernel.sh reboot param1=xxx param2=yyy
   \endcode
   or add them to the \c kernel
   line of the \c grub menu in \c /boot/grub/menu.lst (\c grub \c v1)
   or to the \c GRUB_CMDLINE_LINUX variable in \c /etc/defaults/grub .

   After restart, check for the number of CPUs in \c /proc/cpuinfo -
   they might be reduced by these parameters! Or:
   \code
sudo ./makertaikernel.sh info | grep cores
   \endcode

-# Then run the tests from the RTAI test suite by calling
   \code
sudo ./makertaikernel.sh test          # runs the kern tests
sudo ./makertaikernel.sh test kern     # runs the kern tests
sudo ./makertaikernel.sh test kthreads # runs the kthreads tests
sudo ./makertaikernel.sh test user     # runs the user tests
sudo ./makertaikernel.sh test all      # runs all tests
   \endcode

   The tests need to be manually terminated by pressing \c CTRL-\c C.

   For automatic termination of the tests provide the duration for the
   latency test as a simple number (seconds):
   \code
sudo ./makertaikernel.sh test 60       # runs the kern latency test for 60 seconds
   \endcode
   For preventing any user interaction you can also provide the test
   description after the "auto" keyword (here "basic"):
   \code
sudo ./makertaikernel.sh test 60 auto basic
   \endcode

   The test results are saved into the latencies-* files. View them with a text editor or
   \code
less -S latencies-4.4.115-rtai-5.1-aeshna-004-2018-03-29-regularnohz-good
   \endcode

   The following sections explain how to manually run the tests and
   how to interpret the test results:

-# Run the RTAI latency test
   \code
cd /usr/realtime/testsuite/kern/latency
./run
   \endcode
   The output looks like this:
   \code
RTAI Testsuite - KERNEL latency (all data in nanoseconds)
RTH|    lat min|    ovl min|    lat avg|    lat max|    ovl max|   overruns
RTD|         60|         60|        141|       1040|       1040|          0
RTD|         61|         60|        126|        372|       1040|          0
RTD|         66|         60|        127|        364|       1040|          0
RTD|         66|         60|        128|        748|       1040|          0
RTD|         92|         60|        129|        719|       1040|          0
   \endcode
   If you have overruns, or the maximum latencies "lat max" are too
   high (<2000 ns is awesome, <10000 is good, <20000 is kind of ok, longer than 20000 ns is bad)
   then you need to improve your kernel configuration (\ref configurekernel).

   Also run the switch test:
   \code
cd /usr/realtime/testsuite/kern/switches
./run
   \endcode
   The output looks like this:
   \code
Apr  7 16:08:45 knifefish kernel: [  178.940333] 
Apr  7 16:08:45 knifefish kernel: [  178.940333] Wait for it ...
Apr  7 16:08:45 knifefish kernel: [  178.959986] 
Apr  7 16:08:45 knifefish kernel: [  178.959986] 
Apr  7 16:08:45 knifefish kernel: [  178.959986] FOR 10 TASKS: TIME 5 (ms), SUSP/RES SWITCHES 40000, SWITCH TIME (INCLUDING FULL FP SUPPORT) 145 (ns)
Apr  7 16:08:45 knifefish kernel: [  178.959988] 
Apr  7 16:08:45 knifefish kernel: [  178.959988] FOR 10 TASKS: TIME 6 (ms), SEM SIG/WAIT SWITCHES 40000, SWITCH TIME (INCLUDING FULL FP SUPPORT) 158 (ns)
Apr  7 16:08:45 knifefish kernel: [  178.959990] 
Apr  7 16:08:45 knifefish kernel: [  178.959990] FOR 10 TASKS: TIME 7 (ms), RPC/RCV-RET SWITCHES 40000, SWITCH TIME (INCLUDING FULL FP SUPPORT) 186 (ns)
   \endcode
   The reported switching times should be well below 1000ns.

   Finally, there is the "preempt" test:
   \code
cd /usr/realtime/testsuite/kern/preempt
./run
   \endcode

-# To really check out the performance of the kernel you should run the tests 
   under heavy load. That is, run some processes like
   - at least one "ping -f somewhere";
   - a "ping -f localhost";
   - a "top" on alpha screen and one on an X screen;
   - a "while "true"; do ls -lR / >list; done"
   - a "while "true"; cat /proc/interrupts; done"
   - dd if=/dev/hda2 of=/dev/hda3 bs=1000k &  # /dev/hda3 needs to be a free partition that is at least as large as /dev/hda2!!!
   .

-# If your test results are not satisfactory, then you need to pass
   kernel parameters to the RTAI kernel or reconfigure the kernel,
   probably disabling some devices, compile and install the kernel
   again, and compile and install rtai again. See \ref configurekernel
   below for hints.

-# You can generate a summary report from all your tested kernels via
   \code
./makertaikernel.sh report | less -S                    # report of all latencies-* files
./makertaikernel.sh report tests/latencies-* | less -S  # report of all latencies-* files in tests/
   \endcode


\section configurekernel Improve the performance of the RTAI-patched kernel

To get a low latency kernel you usually need to improve your kernel
configuration.  The main culprits are power saving modes, frequency
scaling, interrupts, some devices and their drivers. Which ones are
bad usually depends on your specific machine.

Read the file `/usr/local/src/rtai/README.CONF_RMRKS` for some hints.

More information can be found at
`https://www.rtai.org/userfiles/documentation/documents/RTAI_User_Manual_34_03.pdf`,
`https://github.com/ShabbyX/RTAI/blob/master/README.INSTALL`, and the
internet (\ref rtailinks).

\subsection powersavingmodes Disable CPU power saving modes
Most importantly, for newer CPUs like Intel i3/i5/i7 CPUs,
disabling CPU power saving modes improves real-time performance
dramatically. Before you try anything else do:
- Add the kernel parameter `idle=poll` to disable C-state transitions completely.
  This is usually sufficient for a godd RTAI performance.
  See \ref kernelparamhints on how to set kernel parameter.
.

\subsection hyperthreading Hyperthreading

README.CONF_RMRKS says: 
- Under SMP set the number of CPUs equal to the real
  ones and have it matched in RTAI, no hyperthreading intended.
- Even if RTAI can work with hyperthreading enabled, such an option is deprecated
  as a possible cause of latency; in any case try and verify if it is acceptable,
  with your hardware and for your applications.
.

So, check whether you have hyperthreading. Run
\code
./makertaikernel.sh info cpus
\endcode
The top of the output looks like this (Intel i7-4770):
\code
CPU topology, frequencies, and idle states (/sys/devices/system/cpu/*):
cpu topology                   cpu frequency scaling
logical  socket  core  online  freq/MHz      governor
  cpu0        0     0       1     0.800      ondemand
  cpu1        0     1       1     0.800      ondemand
  cpu2        0     2       1     0.800      ondemand
  cpu3        0     3       1     0.800      ondemand
  cpu4        0     0       1     0.800      ondemand
  cpu5        0     1       1     1.000      ondemand
  cpu6        0     2       1     1.200      ondemand
  cpu7        0     3       1     1.400      ondemand
\endcode
If in the "core_id" column the numbers appear twice or more
often, then you run in hyperthreading mode (as is the case in the example).

By reducing the number of CPUs to four, you can eliminate
hyperthreading (see below).

If the topology looks like this (Intel i7-3520M):
\code
CPU topology, frequencies, and idle states (/sys/devices/system/cpu/*):
cpu topology                   cpu frequency scaling
logical  socket  core  online  freq/MHz      governor
  cpu0        0     0       1     2.700      ondemand
  cpu1        0     0       1     2.901      ondemand
  cpu2        0     1       1     2.901      ondemand
  cpu3        0     1       1     2.901      ondemand
\endcode
the trick to simply reduce the number of cpus to the number of actual
cores does not work.

This is an example of a machine without hyperthreading (Intel i5-3570):
\code
CPU topology, frequencies, and idle states (/sys/devices/system/cpu/*):
cpu topology                   cpu frequency scaling
logical  socket  core  online  freq/MHz      governor
  cpu0        0     0       1     3.400     powersave
  cpu1        0     1       1     3.144     powersave
  cpu2        0     2       1     2.863     powersave
  cpu3        0     3       1     3.260     powersave
\endcode
In this case you do not need to do anything.

This is what you need to do when configuring the kernel:
- In "Processor type and features": 
  - In case you have a uniprocessor system, deselect "Symmetric multi-processing support" (\c SMP)
  - Set the "Maximum numbers of CPUs" (\c NR_CPUS) to the number of
    physical cores you have in your machine. The \c makertaiscript.sh
    automatically sets for the RTAI configuration the same number
    of CPUs.  
  .
.

You can also do this via the kernel parameters:
- `maxcpus=<n>`: Maximum number of processors that an SMP kernel
  should make use of.  n >= 0 limits the kernel to using
  'n' processors.  n=0 is a special case, it is equivalent to "nosmp",
  which also disables the IO APIC.
- `nr_cpus=<n>` Maximum number of processors that an SMP kernel could
  support. n >= 1 limits the kernel to supporting 'n'
  processors. Later in runtime you can not use hotplug cpu feature to
  put more cpu back to online.  Just like you compile the kernel
  NR_CPUS=n.
.

Switch off individual CPUs:
\code
echo 0 > /sys/devices/system/cpu/cpuX/online
\endcode
This crashes when inserting rtai_hal (even if CONFIG_RTAI_CPUS is adapted to the lower cpucount).

For more information see:
- https://serverfault.com/questions/235825/disable-hyperthreading-from-within-linux-no-access-to-bios?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa
- https://unix.stackexchange.com/questions/33450/checking-if-hyperthreading-is-enabled-or-not
.

The related kernel configs in the "Processor type and features" submenu
  - "SMT (Hyperthreading) scheduler support"
  - "Multi-core scheduler support"
  .
do not seem to matter.


\subsection cachedmemory Cached memory disruption 

README.CONF_RMRKS: Cached memory disruption can add significant
latencies, till the cache becomes hot again, experienced first hand
after a far jump in the code and data in a digital controller.

???

\subsection cstates CPU power management and frequency scaling

README.CONF_RMRKS:
- Power management, see CONFIG_CPU_FREQ and CONFIG_CPU_IDLE below; on portables 
  battery management too.
- Recent Intel SpeedStepping and Boosting.
- Disable CPU_FREQ.
- Disable CPU_IDLE and INTEL_IDLE, or boot with "intel_idle.max_cstate=0". If you
  want to be sure to have a never sleeping CPU execute, at the lowest priority, 
  your own, per cpu, idle task, i.e. one just doing "while(1);".
- Disable APM and CONFIG_ACPI_PROCESSOR, but not everything related to power management.
  Take also into account that without ACPI enabled you might not see more than 
  a single CPU.
.

See
\code
./makertaikernel.sh info cpu
\endcode
for information on frequency scaling and idle states of your CPUs.

You are on the safe side when you configure the ACPI properties of your kernel as follows
(as you did according to \ref basickernelconfiguration):

In "Power management and ACPI options":
- In "ACPI (Advanced Configuration and Power Interface) Support":
  - Disable "Processor" (\c ACPI_PROCESSOR)
  .
- Disable "CPU Frequency scaling" (\c CPU_FREQ)
- In "CPU Idle":
  - Disable "CPU idle PM support" (\c CPU_IDLE)
  .
.

Instead you can try to only disable
in "Power management and ACPI options":
- Disable "CPU Frequency scaling" (\c CPU_FREQ)
.
In addition, make sure your CPU stays in C0 idle state by passing `idle=poll` to
the kernel parameter to keep the cpus in C0 state via an polling idle
loop. This makes the system run hot and also keeps the CPU frequency
at its maximum.

All the other kernel parameter that control CPU idle states are usually not sufficient:
- `idle=halt` idle cpus enter at maximum the C1 state, higher C-states are disabled. CPU frequency stays close at maximum.
- `intel_idle.max_cstate=1` this leaves us with TWO C-states (POLL and C1)!
- `intel_idle.max_cstate=0` this disables the intel_idle driver and switches to acpi_idle with several C-states
- `processor.max_cstate=1` on its own has no effect when the intel_idle driver is active
- `intel_idle.max_cstate=0 processor.max_cstate=0` sames as `processor.max_cstate=1`
- `intel_idle.max_cstate=0 processor.max_cstate=1` disables C-states higher than C1 like `idle=halt` but cpu frequency might go lower.
- `intel_idle.max_cstate=0 processor.max_cstate=2` this leaves you with three C-states (POLL, C1, C2)
- `intel_pstate=disable` ???
.

With
\code
./makertaikernel.sh test batch cstates
\endcode
you can generate a test-batch file to check these kernel parameter.

Some more advice in this context:
- For older RTAI (<5.0) or kernels (<4.0?) adding both
  `intel_idle.max_cstate=0 processor.max_cstate=0 idle=poll` is helpful.
- Just a note: the cstates can also be dynamically controlled by writing the
  maximum allowable latency in microseconds (as an 32-bit(?) \c int, not as
  text) to the file `/dev/cpu_dma_latency` . Writing a zero keeps the
  system in `cstate=0`.
- A second note: monitor cstates
  - Run \c i7z or \c powertop (as root) to see cstates and CPU
    temperatures (they should be well below 100 degrees celsius).
  - For this to work, make sure that in the kernel configuration you
    enabled "/dev/cpu/ * /msr - Model-specific register support" and
    "/dev/cpu/ * /cpuid - CPU information support" in the "Processor type
    and features" submenu.
  .
  See also \c Documentation/power/pm_qos_interface.txt in your kernel
  source tree in \c /usr/src/linux and
  http://stackoverflow.com/questions/12111954/context-switches-much-slower-in-new-linux-kernels
.

You may also try turning off frequency scaling on a specific CPU (the one that runs your RTAI task):
https://wiki.archlinux.org/index.php/CPU_frequency_scaling

For more information on cpu power management and frequency scaling read in the `Documentation` folder in the kernel source
- `cpuidle/sysfs.txt`
- `cpu-freq/cpufreq-stats.txt`
- `cpu-freq/boost.txt`
- `cpu-freq/user-guide.txt`
- `cpu-freq/governors.txt`
- `cpu-freq/intel-pstate.txt`


\subsection acpi ACPI

You may also try:
- acpi=off    # often very effective, but weired system behavior
- acpi=noirq
- pci=noacpi
- pci=nomsi
.

You get these kernel parameters for a test batch file by running
\code
./makertaikernel.sh test batch acpi
\endcode


\subsection processorfamily Select processor family

README.CONF_RMRKS: 
- If unsure on the CPU to choose, care of setting one
  featuring the Time Stamp Clock (TSC), which means no 486 and "false"
  i586, since generic INTEL i586 compatibles often do not have a TSC,
  while true INTEL ones do have it.
.

Check your processor by running
\code
./makertaikernel.sh info cpus
\endcode
The last part looks like this:
\code
CPU (/proc/cpuinfo):
  model name    : Intel(R) Core(TM) i7-3520M CPU @ 2.90GHz
  number of cpus: 4
  cpu family: 6
  cpuidle driver: intel_idle
  machine (uname -m): x86_64
  memory (free -h)  : 7.5G RAM
\endcode

Select your processor in the kernel configuration:
- "Processor type and features":
  - "Processor family"
  .
.
In the kernel menu check \c "help" to find out, which processor family you have to select.
Processors with "cpu family : 6" are "Core 2/newer Xeon".


\subsection lowlatencykernel Low-latency kernel configuration

- "Processor type and features":
  - Select "Preemption Model (Preemptible kernel (Low-Latency Desktop))" (\c PREEMPT)
  - Set "Timer frequency" to 1000Hz (`CONFIG_HZ_1000=y` and `CONFIG_HZ=1000`)
  .
.


\subsection disabledevices Disable device drivers you do not need
A good strategy is to disable as many as possible device drivers.
See
\code
lsmod
\endcode
for listing all the currently loaded kernel modules. Or
\code
lsmod -k
\endcode
for a list of PCI devices on your system and their associated kernel modules.

When configuring the kernel you can hit '/', enter a search term (the
module name) and you get a list of matching configuration parameters.

Devices to consider are:
- Disable DRM:
  - Device Drivers:
    - Graphics support:
      - Disable "Direct Rendering Manager"
      .
    .
  .

- Check video cards and graphic acceleration
  
  README.CONF_RMRKS: 
  - Some peripherals, e.g. video cards, may stall CPUs attempting to
    access IO space.  Verify "what ifs" related to graphic
    acceleration, likely better if disabled.  Consider also if X term
    usage is really needed. If possible avoid it, especially in
    production work.
  - Any initialization of the device drivers, or anything related to
    the hardware, may lead to high latencies, e.g., but not
    always. doing "startx &" while a real time application is
    running. Once it is started there should be no major problems.  If
    the truoble persists and you really need X, concurrently with your
    RTAI tasks, try disabling hardware graphic acceleration. The best
    latencies usually come with no graphic application running.
  .

- Disabling the thermal sysfs driver is sometimes great for latencies
  but has no effect on periodic tasks ? ...:
  - Device Drivers:
    - Graphics support:
      - Disable "Backlight & LCD device support"
      .
    - Disable "Generic Thermal sysfs driver"
    .
  . 
  
- Device Drivers:
  - Keep "Real Time Clock"
  - "Generic Dynamic Voltage and Frequency Scaling (DVFS) support" does not matter
  - sound might be ok
  .

- You probably do not need bluetooth or WLAN! (but as long as you do
  not use it it might not hurt...):
  - Device Drivers:
    - Network device support:
      - Disable "Wireless LAN"
      .
    .
  - Networking support:
    - Disable "Bluetooth subsystem support"
    - Disable "Wireless"
    .
  .

- USB: 
  - According to \c README.CONF_RMRKS from rtai-5.0.1:
    "Do not disable USB, but just any legacy support, possibly in the
    BIOS also. Once upon a time old USB was a source of high RTAI
    latencies. Now that should be legacy support."
  - If you get the error "usb: device not accepting address" add 
    \c noapic to the kernel parameter.
  .
  
.

\subsection otherconfigs Some more hints for kernel configuration parameters
Here is a list of some kernel configuration parameter that you might try to improve your
real-time perfomance (low latencies):

- In "Device drivers" keep "Multiple devices driver support (RAID and LVM)" 
  and in there keep "Device mapper support" (somehow needed for grub).

- In "Processor type and features": disabling the following seems to have an effect: 
  - Disable "Supervisor Mode Access Prevention"
  - Disable "EFI runtime service support"
  - Disable "Enable seccomp to safely compute untrusted bytecode"
  .

- NUMA (disabling seems to improve maximum latencies):
  - General setup:
    - Disabel "Memory placement aware NUMA scheduler"
  - Processor type and features: 
    - Disable "Numa Memory Allocation and Scheduler Support"
    .
  .

- HPET Timer (disabling it improves preempt jitter):
  - Device Drivers:
    - Character devices:
      - Disable "HPET - High Precision Event Timer"
      .
    .
  .

- Disable IOMMU (no effect?):
  - Processor type and features: 
    - Disable "Old AMD GART IOMMU support"
    - Disable "IBM Calgary IOMMU support"
    .
  - Device Drivers:
    - Disable IOMMU Hardware Support
    .

- Maybe also try:
  - CONFIG_RCU_BOOST and CONFIG_RCU_KTHREAD_PRIO
  .
.


\subsection kernelparamhints Kernel parameter

There are several interesting kernel parameter that influence the
real-time performance.

See the file \c Documentation/kernel-parameters.txt in your linux
kernel source tree (in \c /usr/src) for a documentation of all kernel
parameter.

You can pass kernel parameter directly to the reboot command:
\code
sudo ./makertaikernel.sh reboot XXX
\endcode
where [XXX] are kernel parameter to be used for booting the
kernel (they are added permanently to the \c
GRUB_CMDLINE_LINUX_DEFAULT variable in \c /etc/default/grub). The
original settings are recovered when calling \c reboot \c default).

See
\code
sudo ./makertaikernel.sh help reboot
\endcode
for further options and details.

Here is a list of potentially influential kernel parameter:

CPU frequency scaling and power control:
- `idle=poll` disables c-state transitions completely and disables cpuidle driver.
- Disable the intel_idle module. Alternatively you can set \c
  intel_idle.max_cstate=0 . This is taken care of by the disabled "CPU
  Idle" in "Power management and ACPI options".
- check out
  https://gitlab.eurecom.fr/oai/openairinterface5g/wikis/OpenAirKernelMainSetup
  for more hints on disabling power-management and frequency scaling
  stuff
- Check frequency scaling of CPUs with \a cpufreq-info from the \c cpufrequtils package.
.

Clocks and timers:
- \c nohz=off
- \c tsc=reliable
- \c highres=off
- \c hpet=disable
- For scheduling interrupts read \c Documentation/timers/NO_HZ.txt
- Also check out "nohalt" kernel parameter.
.

Advanced configuration and power interface (ACPI):
- \c acpi=off , although effective this may results in an unstable system
- \c pci=noacpi .
- With disabled acpi your rtai-patched linux kernel might not properly
  halt or reboot. Try \c reboot=triple as a kernel parameter.  See \c
  /usr/src/linux/Documentation/x86/x86_64/boot-options.txt for more
  options for the reboot parameter.
.

Advanced programmable interrupt controller (APIC):
- \c noapic
- \c nolapic , usually not a good idea, becaus RTAI uses the lapic timer. 
- \c lapic
.

Others:
- disable all DMA transfers by setting kernel parameter \c libata.dma=0.
  
  What about \c ide-core.nodma parameter (it's ide not sata!)?

  What about ltpc=irq ?

  README.CONF_RMRKS: LINUX use of DMA can add latency, especially when
  it is supported in burst mode.

.

Supply the kernel parameter to the \c reboot action of \c makertaikernel.sh:
\code
$ makertaikernel.sh reboot param1=xxx param2=yyy ...
\endcode

If you want to test many kernel parameter you can completely
automatize this with the \c makertaikernel.sh script. Create a file in
which each line contains a description of the kernel parameters, a
colon ':', and the kernel parameters as they sould be passed to the
kernel. You may start out with the \c testkernelparams.mrk file that
you get by calling 
\code 
$ makertaikernel.sh test batch default
\endcode
Modify this file according to your needs or create your own one. Then calling
\code 
$ makertaikernel.sh test 90 batch testkernelparams.mrk
\endcode
will reboot with the first set of kernel parameter, automatically run
the test, save the results using the description of the parameter,
reboot with the next kernel parameters, and so on until all kernel
parameter have been tested (or the system hangs). After the last test
the default kernel is booted with its original kernel parameter. In
the directory where you executed the script you will find all the test
results. Analyse them with
\code 
$ makertaikernel.sh report latencies-*
\endcode

If you want to stop automatic rebooting before all configurations have been tested run
\code 
$ makertaikernel.sh restore testbatch
\endcode

Alternatively, you can set kernel parameters during startup by hitting 'e' in the \c
grub menu and then add them to the \c kernel line.

For applying the kernel parameter permanently add them in \c
/boot/grub/menu.lst (\c grub \c v1) or to the \c GRUB_CMDLINE_LINUX_DEFAULT
variable in \c /etc/defaults/grub and run \c update-grub.

After restart, check for the number of CPUs in \c /proc/cpuinfo - they
might be reduced if you disabled too much ACPI!


\subsection rtaiisolcpus Isolate CPUs for real time tasks 
For further improving the RTAI performance, you might want to reserve
at least one CPU for RTAI on a multi-core machine. You can isolate
CPUs by using the kernel parameter
\code
isolcpus=0,1
\endcode
(for isolating the cores no. 0 and 1). Additional parameters are
\code
isolcpus=0,1 nohz_full=0,1 rcu_nocbs=0,1
\endcode
See the file \c /usr/local/src/rtai/README.ISOLCPUS for more details.


\subsection biosparameter Check your BIOS
Sometimes it also helps to set/disable things in the BIOS:
- Force all fans to run at full speed
- Disable CPU power saving modes
.

\subsection disablesmi Disable SMI interrupts
Finally, there are the evil SMIs. They periodically produce some long latencies. See \c
/usr/local/src/rtai/base/arch/x86/calibration/README.SMI and \c README.SMISPV for details.


\section installrelacs Setting up dynamic clamp for RELACS
You should install \c RTAI and the \c comedi drivers and library prior to
configuring RELACS, so that ./configure can detect the presence of the
\c comedi library. If you install \c RTAI and \c comedi later, simply run \c
./configure and \c make again to detect comedi and compile the
corresponding plugins for RELACS.

-# Login as a normal user
-# If you are not member of the \c iocard group (necessary for accessing the comedi devices, 
   see \ref udev), then
   \code
sudo adduser $USER iocard
   \endcode
   \note You need to log out and log in again to actually be member of that group.
-# \c cd into the RELACS top-level directory and run
   \code
./configure
   \endcode
   This should detect comedi and RTAI (see message towards the end of the output of \c configure).
-# Then get rid of any previously compiled comedi and dynamic clamp modules:
   \code
cd plugins/linuxdevices/comedi
make clean
make -j$(grep -c "^processor" /proc/cpuinfo)
cd -
cd plugins/linuxdevices/rtaicomedi
make clean
   \endcode
-# Select features of the dynamic clamp module by commenting or uncommenting the defines
at the top of the file \c plugins/linuxdevices/rtaicomedi/module/moduledef.h
or by enabling them by the --enable-dynclamp options for ./configure
(see ./configure --help for a description of all available options).
-# Implement your dynamic clamp model in the file \c plugins/linuxdevices/rtaicomedi/module/model.c .
-# Compile the dynamic clamp plugins and the kernel module
\code
cd plugins/linuxdevices/rtaicomedi
make -j$(grep -c "^processor" /proc/cpuinfo)
\endcode
-# If you get an "-mpreferred-stack-boundary" error uncomment line 4 in \c plugins/linuxdevices/rtaicomedi/module/Makefile.in and run \c make again.
-# Load the dynamic-clamp kernel module (as root):
\code
sudo module/loadmodules.sh
\endcode
-# Run RELACS in \c plugins/linuxdevices/rtaicomedi :
\code
./relacslocal
\endcode
or with the patchclamp plugins:
\code
cd plugins/patchclamp
cp relacs.cfg.dynclamp relacs.cfg
./relacslocal
\endcode
-# Possible problems are:
  - Data acquisition does not start:
    - You might not have 
      sufficient permissions for reading and writing to the 
      \c /dev/comedi* devices. For a quick fix do
      \code
sudo chmod a+rw /dev/comedi*
      \endcode
      See \ref udev for a better solution.
    - The %comedi and rtai modules are not properly loaded: check the output of \c module/loadmodules.sh and \c dmesg.
    - The %comedi device is not configured yet (should not be a problem with a recent comedi version).
    .
  - Performance is bad / RELACS regularly hangs for a few seconds / RELACS seems to be slowed down dramatically:
    - Improve your rtai kernel! See \ref configurekernel for instructions.
    .
  .
-# When developing your dynamic clamp model in \c model.c or if you dare to modify \c dynclampmodule.c, then
\code
# cd to rtaicomedi/, not rtaicomedi/module/ !
cd plugins/linuxdevices/rtaicomedi
# whenever you changed something, do:
make
sudo module/reloadmodule.sh
\endcode
Your \c model.c implementation can be tested without RTAI in the simulation mode of relacs, see \ref simulatedynclamp below.
-# If you want to load the dynamic-clamp kernel module automatically during 
the boot process, then call the \c loadmodules.sh script from the script
\c /etc/rc.local . Simply add a line like this
\code
/where/ever/the/script/is/located/loadmodules.sh
\endcode
to \c /etc/rc.local (as root).


\section configdynamicclamp Configure dynamic clamp in RELACS

Just make sure your \c relacs.cfg file has the following device sections:
\code
*Analog Input Devices
  Device1:
      plugin: [ DynClampAnalogInput, DynClampAISim ]
      device: /dev/comedi0
      ident : ai-1

*Analog Output Devices
  Device1:
      plugin: [ DynClampAnalogOutput, DynClampAOSim ]
      device: /dev/comedi0
      ident : ao-1
\endcode

\subsection inputtraces  Input traces 
As usual, input traces can be assigned to channels
of the analog input device. All the input traces the dynamic clamp
model requires (its \c inputNames) must be available.

The dynamic clamp plugins provide some additional input traces. They can be accessed like
normal analog input traces, but the channel nummber needs to be set to 1000 or larger.
The following three types of additional inputs are supported:
- Additional inputs as defined by the dynamic clamp model via its \c paramInputNames.
- Timing measurements, if they are enabled in moduledef.h:
  - \c Interval : the full period of each cycle of the dynamic clamp loop (always available)
  - \c AI-time : the time required by the analog input part
  - \c AI-acquisition-time : the time required by reading in a single analog input channel
  - \c AI-conversion-time : the time required to convert the read in value
  - \c AO-time : the time required by the analog output part
  - \c Model-time : the time required for calling computModel()
  - \c Wait-time : the time rt_task_wait_period() waits for the next period
  .
  all times are measured in seconds.
- For each analog output trace the dynamic clamp model is using (its \c outputNames)
  the following input traces are available:
  - \c Stimulus-xxx contains the stimulus a RePro wrote to this channel,
  - \c Model-xxx contains the value the model computed, and
  - \c Total-xxx contains the total requested output for this channel, i.e. Stimulus-xxx plus Model-xxx.
  - \c Injected-xxx contains the total output for this channel as it is written to the analog output.
    This equals \c Total-xxx multiplied by a possible correction factor and is only available with ENABLE_SYNCSEC
  .
  \c xxx is the name of the analog output trace. If the Injected or Total output exceeds the limits of the 
  maximum range of the data acquisition board, they are clipped to the minimum or maximum possible values.

\subsection outputtraces Output traces 
As usual, output traces can be assigned to channels
of the analog output device. All the output traces the dynamic clamp
model requires (its \c outputNames) must be available.

Additional output traces as defined by the dynamic clamp model via its
\c paramOutputNames can be accessed like normal analog output traces by
their name.


\section simulatedynclamp Dynamic clamp simulation 
You can run the dynamic clamp in the relacs simulation mode as well.
This is in particular handy when it comes to testing your \c model.c
implementation without RTAI.

The relacs::DynClampAISim and relacs::DynClampAOSim modules do the trick.

Whenever you change \c model.c you need to recompile the
\c DynClampAISim and \c DynClampAOSim modules by calling \c make in the 
\c plugins/linuxdevices/rtaicomedi directory.
\code
cd plugins/linuxdevices/rtaicomedi
make
\endcode

Then call \c relacs with the \c -3 option
\code
./relacslocal -3
\endcode
and enjoy the simulation.

*/
