/*!
\mainpage RTAI-comedi Relacs Plugins

\brief Plugins for dynamic clamp based on RTAI and comedi.

\section rtaicomedicontent Content
- \ref rtaicomediintro
- \ref quickinstall
- \ref testrtai
- \ref configurekernel
- \ref installrelacs
- \ref configdynamicclamp
- \ref simulatedynclamp

\section rtaicomediintro Introduction

For using dynamic clamp, i.e. some realtime computation, as it is
implemented by the DynClampAnalogInput and DynClampAnalogOutput
plugins, you need to install an RTAI-patched real-time linux
kernel, RTAI kernel modules, and comedi device drivers.

RELACS provides a script that helps you in the installation process.
This is described in the following section \ref quickinstall. The
script should work on debian based systems, but is has not been tested
on other Linux distributions.

Alternatively, you can do the installation manually as explained in
\ref manualinstall .

In either case, continue with building the dynamic clamp module of
RELACS as explained in \ref installrelacs and configuring RELACS
as explained in \ref configdynamicclamp .

If you only want to simulate a dynamic clamp, then skip all
installation procedures and just read \ref simulatedynclamp .


\section quickinstall Install an RTAI-patched linux kernel, RTAI, and comedi

The \c makertaikernel.sh script in \c
plugins/linuxdevices/rtaicomedi/scripts/ executes all the commands
needed to download and build an RTAI-patched linux kernel, the newlib
library (needed for math support), and the RTAI and comedi kernel
modules. 

The script is so far only used and tested on debian based systems and
is likely to fail on other Linux distributions. Feel free to adapt the
script to your Linux distribution.

-# From the relacs source tree go to
   \code
cd plugins/linuxdevices/rtaicomedi/scripts
   \endcode

-# Select an RTAI source (-r option or RTAI_DIR variable, see \c
   ./makertaikernel.sh \c help for options, usually the default should be fine) and run
   \code
sudo ./makertaikernel.sh init
   \endcode
   to make sure you have \c /var/log/messages (needed for RTAI switch
   tests), you get a visible boot menu, have comedi devices assigned
   to the \c iocard group, and have the RTAI sources downloaded.

   This command ends with showing you the RTAI kernel patches
   available for your machine.

-# Select a Linux kernel and the corresponding RTAI patch from the displayed list.

   Modify the variables at the top of the \c makertaikernel.sh script
   or set them before executing makertaikernel.sh, in particular the
   \c LINUX_KERNEL, \c RTAI_PATCH, and \c KERNEL_PATH variables to
   match the kernel version, rtai patch you want to use, and the
   directory where to build the linux kernel (you need up to 2 GB
   space there for a kernel with most device drivers disabled
   (e.g. via localmodconf) or 5-10GB for a full kernel).

   Recheck for available RTAI patches and linux kernels:
   \code
sudo ./makertaikernel.sh info rtai
   \endcode

-# You should start out with a kernel
   configuration of a kernel image from your linux distribution
   closest to the kernel version you selected. On a Debian-based
   system install a matching kernel by executing
   \code
sudo apt-get install linux-image-4.4.0-79-lowlatency
   \endcode
   (modify it to the kernel version you want, use the tab-key for
   autocompletion) and boot into this kernel. Either restart your computer
   and select the kernel from the grub boot menu or check the grub menu with
   \code
sudo ./makertaikernel.sh info grub
   \endcode
   and reboot using
   \code
sudo ./makertaikernel.sh reboot 3
   \endcode
   replace '3' by the index of the appropriate menu entry. The latter
   has the advantage that it doesn't matter to miss the boot menu.

   Starting out with a kernel matching the one from the selected RTAI
   patch ensures that makertaikernel.sh will use this kernel's
   configuration and deselect all kernel modules that are not used
   (localmodconfig). This dramatically shortens the compile time.

   If you use \c makertaikernel.sh with the \c -l switch or the
   version of the running kernel does not match the one of the
   selected kernel (major or minor version number differ),
   localmodconfig is not applied, resulting in a much larger kernel
   (takes much more time to compile).

-# Once you booted into the kernel on which you want to base your RTAI
   kernel run
   \code
sudo ./makertaikernel.sh
   \endcode

   This will download the required sources (takes a while...) and
   build the kernel using the kernel configuration of the running
   kernel (takes even more time...). 

   With the `-c` flag you can provide a different kernel configuration
   on which the kernel configuration should be based (see \c
   makertaikernel.sh \c help for details).

-# You will get the menu for configuring the kernel. This is the most
   important step! See \ref basickernelconfiguration for instructions.

-# Reboot into the new kernel by executing
   \code
sudo ./makertaikernel.sh reboot
   \endcode

-# Once you booted into the RTAI kernel run some tests by invoking
   \code
sudo ./makertaikernel.sh test
   \endcode
   to run the "kern" tests.
   See 
   \code
sudo ./makertaikernel.sh test help
   \endcode
   for possible options of the test action.
   For example, run the tests without user interaction for 30 seconds and name
   the test results "basic":
   \code
sudo ./makertaikernel.sh test 30 auto basic
   \endcode

   The result of the tests is written into the file
   \c latencies-KERNEL-RTAI-HOST-NNN-DATE-NAME-QUALITY and the
   corresponding kernel configuration is saved in
   \c config-KERNEL-RTAI-HOST-NNN-DATE-NAME_QUALITY in the current
   directory. KERNEL is replaced by the kernel version, RTAI by your
   choice of an RTAI source (e.g. magma, rtai-5.1, etc.), HOST is the
   hostname of your machine, NNN is replaced by a consecutive number,
   DATE is the current date, NAME and QUALITY are short strings
   describing your kernel configuration and the test performance that
   is retrieved from the latency test.

   See \ref testrtai for details regarding the test results and \ref configurekernel
   for troubleshooting and how to improve the real time performance.

-# If you did not start out with a kernel version matching the version
   of your RTAI-patched kernel, then before you go on with improving
   the kernel configuration run
   \code
sudo ./makertaikernel.sh -c mod
   \endcode
   in order to deselect all unused kernel modules from compilation. 
   This speeds up the following kernel builds dramatically! Then reboot and test.

-# If the test results do not satisfy you, then build a new version of
   the kernel with a different configuration (see \ref configurekernel
   for details) and a different name (\c -n option). The name can be
   any string without whitespace - a simple number or a string
   describing the configuration of the kernel:
   \code
sudo ./makertaikernel.sh -n 2 reconfigure
   \endcode
   reboot into the new kernel, test the new kernel, reconfigure again yet another kernel (with a different name):
   \code
sudo ./makertaikernel.sh -n 2 reboot
...
sudo ./makertaikernel.sh -n 2 test
sudo ./makertaikernel.sh -n 1 reconfigure
   \endcode
   reboot, and do the same with the right kernel names:
   \code
sudo ./makertaikernel.sh -n 1 test
sudo ./makertaikernel.sh -n 2 reconfigure
   \endcode

   Note that \c makertaikernel.sh \c reconfigure will first uninstall
   an already existing kernel with the same name (this is why we need
   to work with at least two different kernel names).

   You can recreate this kernel or use this kernel's configuration for
   further modifications by specifying the kernel configuration file
   saved by \c makertaikernel.sh \c test using the `-c` option
   \code
sudo ./makertaikernel.sh -n 1 -c config-3.14.17-rtai-4.1-002-basic-good reconfigure
   \endcode
-# Once you are satisified, continue with \ref installrelacs .

For further options of the \c makertaikernel.sh script see
\code
./makertaikernel.sh help
\endcode
To show some information about your machine, RTAI patches, grub menue, etc. run
\code
./makertaikernel.sh info
\endcode


\section basickernelconfiguration Kernel configuration
For making the Linux kernel work with RTAI you need to check the following settings 
in the kernel configuration dialog.

Also read /usr/local/src/rtai/README.CONF_RMRKS !

- General setup: 
  - Make sure that "Local version" is empty in case you are using the \c makertaikernel.sh script or \c make-kpkg (Debian system).
    Otherwise set "Local version" to "-rtai" or something else indicating that this is a RTAI patched kernel.
  - Disable "Enable sytem-call auditing support"
  - Disable "Configure standard kernel features (expert users)"
  - Set "Stack Protector buffer overflow detection" to "Regular" or even "None" if the latency test crashes.
  .
- Processor type and features: 
  - Select "Symmetric multi-processing support" (SMP) if you have a multiprocessor machine, otherwise (uniprocessor system, UP) deselect it
  - Select the right Processor family (you find the name of your processor by looking at \c /proc/cpuinfo,
    check \c "help" to find out, which Processor family you have to select.
    Intel i5/i7 with "cpu family : 6" are "Core 2/newer Xeon")
  - Set the "Maximum numbers of CPUs" to the number of physical cores you have in your machine (check in \c /proc/cpuinfo the \c "cpu cores")
  - Disable "SMT (Hyperthreading) scheduler support"
  - Disable "Multi-core scheduler support"
  - Select "Preemption Model (Preemptible kernel (Low-Latency Desktop))"
  - Keep "Interrupt pipeline" selected
  - "I-pipe legacy interface": kee disabled for RTAI 5.x, enable for rtai-4.1 (and earlier?)
- Power management and ACPI options:
  - Disable everything except for:
  - Enable "ACPI (Advanced Configuration and Power Interface) Support"
    - Disable everything except for:
    - Select "Power Management Timer Suppport" (if available)
    .
  - In particular disable "CPU Frequency scaling" (\c CPU_FREQ)
  - In particular disable "CPU idle PM support" (\c CPU_IDLE)
  .
- Device Drivers:
  - Staging drivers:
    - Deselect "Data acquisition support (comedi)"
    .
  .
- Kernel hacking: disabling debugging makes the kernel much smaller. So unless you know that you need it disable it.
  - Compile-time checks and compiler options:
    - Disable "Compile the kernel with debug info"
  .
  - Disable "Kernel debugging"
  - Disable "Tracers"
.
- Disable "Virtualization" if possible unless you know that you need it.
.
Leave the configuration dialog by pressing "Exit" until you are asked "Save kernel config?".
Select "Yes".

Then the new kernel is being compiled - be patient.


\section testrtai Testing performance of RTAI kernel

Testing your RTAI patched kernel is crucial for a good real-time performance!

-# The \c makertaikernel.sh can also be used for testing with the advantage that it writes
   the test results and the kernel configuration into files.

   The script will first ask for a short description of your kernel
   configuration and parameter. This string is then used for naming
   the files for the test results.

-# Test RTAI by loading some modules:
   \code
cd /usr/realtime/modules
insmod rtai_hal.ko
insmod rtai_sched.ko
insmod rtai_math.ko
   \endcode

   This is done by
   \code
sudo ./makertaikernel.sh test none
   \endcode
If you only want to check insmodding \c rtai_hal then call
   \code
sudo ./makertaikernel.sh test hal none
   \endcode
Equivalently, you can use the \c sched and \c math option.

   If this fails:

   First, check the output of
   \code
dmesg
   \endcode
   for some hints.

   Try adding one or several of the advanced configuration and power
   interface (ACPI) or advanced programmable interrupt controller
   (APIC) options, \c acpi=off, \c pci=noacpi, \c noapic, \c nolapic,
   or \c lapic, to the kernel parameter.

   Either provide the kernel parameter to \c makertaikernel.sh:
   \code
sudo ./makertaikernel.sh reboot param1=xxx param2=yyy
   \endcode
   or add them to the \c kernel
   line of the \c grub menu in \c /boot/grub/menu.lst (\c grub \c v1)
   or to the \c GRUB_CMDLINE_LINUX variable in \c /etc/defaults/grub .

   After restart, check for the number of CPUs in \c /proc/cpuinfo -
   they might be reduced by these parameters! Or:
   \code
sudo ./makertaikernel.sh info | grep cores
   \endcode

-# Then run the tests from the RTAI test suite by calling
   \code
sudo ./makertaikernel.sh test          # runs the kern tests
sudo ./makertaikernel.sh test kern     # runs the kern tests
sudo ./makertaikernel.sh test kthreads # runs the kthreads tests
sudo ./makertaikernel.sh test user     # runs the user tests
sudo ./makertaikernel.sh test all      # runs all tests
   \endcode

   The tests need to be manually terminated by pressing \c CTRL-\c C.

   For automatic termination of the tests provide the duration for the
   latency test as a simple number (seconds):
   \code
sudo ./makertaikernel.sh test 60       # runs the kern latency test for 60 seconds
   \endcode
   For preventing any user interaction you can also provide the test
   description after the "auto" keyword (here "basic"):
   \code
sudo ./makertaikernel.sh test 60 auto basic
   \endcode

   The test results are saved into the latencies-* files. View them with a text editor or
   \code
less -S latencies-4.4.115-rtai-5.1-aeshna-004-2018-03-29-regularnohz-good
   \endcode

   The following sections explain how to manually run the tests and
   how to interpret the test results:

-# Run the RTAI latency test
   \code
cd /usr/realtime/testsuite/kern/latency
./run
   \endcode
   The output looks like this:
   \code
RTAI Testsuite - KERNEL latency (all data in nanoseconds)
RTH|    lat min|    ovl min|    lat avg|    lat max|    ovl max|   overruns
RTD|         60|         60|        141|       1040|       1040|          0
RTD|         61|         60|        126|        372|       1040|          0
RTD|         66|         60|        127|        364|       1040|          0
RTD|         66|         60|        128|        748|       1040|          0
RTD|         92|         60|        129|        719|       1040|          0
   \endcode
   If you have overruns, or the maximum latencies "lat max" are too
   high (<2000 ns is awesome, <10000 is good, <20000 is kind of ok, longer than 20000 ns is bad)
   then you need to improve your kernel configuration (\ref configurekernel).

   Also run the switch test:
   \code
cd /usr/realtime/testsuite/kern/switches
./run
   \endcode
   The output looks like this:
   \code
Apr  7 16:08:45 knifefish kernel: [  178.940333] 
Apr  7 16:08:45 knifefish kernel: [  178.940333] Wait for it ...
Apr  7 16:08:45 knifefish kernel: [  178.959986] 
Apr  7 16:08:45 knifefish kernel: [  178.959986] 
Apr  7 16:08:45 knifefish kernel: [  178.959986] FOR 10 TASKS: TIME 5 (ms), SUSP/RES SWITCHES 40000, SWITCH TIME (INCLUDING FULL FP SUPPORT) 145 (ns)
Apr  7 16:08:45 knifefish kernel: [  178.959988] 
Apr  7 16:08:45 knifefish kernel: [  178.959988] FOR 10 TASKS: TIME 6 (ms), SEM SIG/WAIT SWITCHES 40000, SWITCH TIME (INCLUDING FULL FP SUPPORT) 158 (ns)
Apr  7 16:08:45 knifefish kernel: [  178.959990] 
Apr  7 16:08:45 knifefish kernel: [  178.959990] FOR 10 TASKS: TIME 7 (ms), RPC/RCV-RET SWITCHES 40000, SWITCH TIME (INCLUDING FULL FP SUPPORT) 186 (ns)
   \endcode
   The reported switching times should be well below 1000ns.

   Finally, there is the "preempt" test:
   \code
cd /usr/realtime/testsuite/kern/preempt
./run
   \endcode

-# To really check out the performance of the kernel you should run the tests 
   under heavy load. That is, run some processes like
   - at least one "ping -f somewhere";
   - a "ping -f localhost";
   - a "top" on alpha screen and one on an X screen;
   - a "while "true"; do ls -lR / >list; done"
   - a "while "true"; cat /proc/interrupts; done"
   - dd if=/dev/hda2 of=/dev/hda3 bs=1000k &  # /dev/hda3 needs to be a free partition that is at least as large as /dev/hda2!!!
   .

-# If your test results are not satisfactory, then you need to pass
   kernel parameters to the RTAI kernel or reconfigure the kernel,
   probably disabling some devices, compile and install the kernel
   again, and compile and install rtai again. See \ref configurekernel
   below for hints.

-# You can generate a summary report from all your tested kernels via
   \code
./makertaikernel.sh report | less -S                    # report of all latencies-* files
./makertaikernel.sh report tests/latencies-* | less -S  # report of all latencies-* files in tests/
   \endcode


\section configurekernel Improve the performance of the RTAI-patched kernel

To get a low latency kernel you usually need to improve your kernel
configuration.  The main culprits are power saving modes, frequency
scaling, interrupts, some devices and their drivers. Which ones are
bad usually depends on your specific machine.

Read the file `/usr/local/src/rtai/README.CONF_RMRKS` for some hints.

More information can be found at
`https://www.rtai.org/userfiles/documentation/documents/RTAI_User_Manual_34_03.pdf`,
`https://github.com/ShabbyX/RTAI/blob/master/README.INSTALL`, and the
internet (\ref rtailinks).

\subsection powersavingmodes Disable CPU power saving modes
Most importantly, for newer CPUs like Intel i5 and Intel i7 CPUs,
disabling CPU power saving modes improves real-time performance
dramatically. Before you try anything else do:
- Add the kernel parameter `idle=poll` . This is usually sufficient.
  See \ref kernelparamhints on how to set kernel parameter.
- For older RTAI (<5.0) or kernels (<4.0?) adding both
  `processor.max_cstate=0 idle=poll` is helpful. In more recent
  contexts, however, `processor.max_cstate=0` seems to make things
  worse.
- Just a note: the cstates can also be dynamically controlled by writing the
  maximum allowable latency in microseconds (as an 32-bit(?) \c int, not as
  text) to the file `/dev/cpu_dma_latency` . Writing a zero keeps the
  system in `cstate=0`.
- A second note: monitor cstates
  - Check cpu idle driver and intel max_cstate setting with
    \code
cat /sys/devices/system/cpu/cpuidle/current_driver
cat /sys/module/intel_idle/parameters/max_cstate
    \endcode
  - Run \c i7z or \c powertop (as root) to see cstates and CPU
    temperatures (they should be well below 100 degrees celsius).
  - For this to work, make sure that in the kernel configuration you
    enabled "/dev/cpu/ * /msr - Model-specific register support" and
    "/dev/cpu/ * /cpuid - CPU information support" in the "Processor type
    and features" submenu.
  .
  See also \c Documentation/power/pm_qos_interface.txt in your kernel
  source tree in \c /usr/src/linux and
  http://stackoverflow.com/questions/12111954/context-switches-much-slower-in-new-linux-kernels
.


\subsection kernelparamhints Kernel parameter

There are several interesting kernel parameter that influence the
real-time performance.

See the file \c Documentation/kernel-parameters.txt in your linux
kernel source tree (in \c /usr/src) for a documentation of all kernel
parameter.

You can pass kernel parameter directly to the reboot command:
\code
sudo ./makertaikernel.sh reboot XXX
\endcode
where [XXX] are kernel parameter to be used for booting the
kernel (they are added permanently to the \c
GRUB_CMDLINE_LINUX_DEFAULT variable in \c /etc/default/grub). The
original settings are recovered when calling \c reboot \c default).

See
\code
sudo ./makertaikernel.sh help reboot
\endcode
for further options and details.

Here is a list of potentially influential kernel parameter:

CPU frequency scaling and power control:
- \c idle=poll
- Disable the intel_idle module. Alternatively you can set \c
  intel_idle.max_cstate=0 . This is taken care of by the disabled "CPU
  Idle" in "Power management and ACPI options".
- check out
  https://gitlab.eurecom.fr/oai/openairinterface5g/wikis/OpenAirKernelMainSetup
  for more hints on disabling power-management and frequency scaling
  stuff
- Check frequency scaling of CPUs with \a cpufreq-info from the \c cpufrequtils package.
.

Clocks and timers:
- \c nohz=off
- \c tsc=reliable
- \c highres=off
- \c hpet=disable
- For scheduling interrupts read \c Documentation/timers/NO_HZ.txt
- Also check out "nohalt" kernel parameter.
.

Advanced configuration and power interface (ACPI):
- \c acpi=off , although effective this may results in an unstable system
- \c pci=noacpi .
- With disabled acpi your rtai-patched linux kernel might not properly
  halt or reboot. Try \c reboot=triple as a kernel parameter.  See \c
  /usr/src/linux/Documentation/x86/x86_64/boot-options.txt for more
  options for the reboot parameter.
.

Advanced programmable interrupt controller (APIC):
- \c noapic
- \c nolapic , usually not a good idea, becaus RTAI uses the lapic timer. 
- \c lapic
.

Others:
- disable all DMA transfers by setting kernel parameter \c libata.dma=0.
.

Supply the kernel parameter to the \c reboot action of \c makertaikernel.sh:
\code
$ makertaikernel.sh reboot param1=xxx param2=yyy ...
\endcode

If you want to test many kernel parameter you can completely
automatize this with the \c makertaikernel.sh script. Create a file in
which each line contains a description of the kernel parameters, a
colon ':', and the kernel parameters as they sould be passed to the
kernel. You may start out with the \c testkernelparams.mrk file that
you get by calling 
\code 
$ makertaikernel.sh test batch default
\endcode
Modify this file according to your needs or create your own one. Then calling
\code 
$ makertaikernel.sh test 90 batch testkernelparams.mrk
\endcode
will reboot with the first set of kernel parameter, automatically run
the test, save the results using the description of the parameter,
reboot with the next kernel parameters, and so on until all kernel
parameter have been tested (or the system hangs). After the last test
the default kernel is booted with its original kernel parameter. In
the directory where you executed the script you will find all the test
results. Analyse them with
\code 
$ makertaikernel.sh report latencies-*
\endcode

If you want to stop automatic rebooting before all configurations have been tested run
\code 
$ makertaikernel.sh restore testbatch
\endcode

Alternatively, you can set kernel parameters during startup by hitting 'e' in the \c
grub menu and then add them to the \c kernel line.

For applying the kernel parameter permanently add them in \c
/boot/grub/menu.lst (\c grub \c v1) or to the \c GRUB_CMDLINE_LINUX_DEFAULT
variable in \c /etc/defaults/grub and run \c update-grub.

After restart, check for the number of CPUs in \c /proc/cpuinfo - they
might be reduced if you disabled too much ACPI!


\subsection disabledevices Disable device drivers you do not need
A good strategy is to disable as many as possible device drivers.
See
\code
lsmod
\endcode
for listing all the currently loaded kernel modules. Or
\code
lsmod -k
\endcode
for a list of PCI devices on your system and their associated kernel modules.

When configuring the kernel you can hit '/', enter a search term (the
module name) and you get a list of matching configuration parameters.

Devices to look out are:
- Disable DRM:
  - Device Drivers:
    - Graphics support:
      - Disable "Direct Rendering Manager"
      .
    .
  .

- Check video cards and graphic acceleration

- Disabling the thermal sysfs driver is sometimes great for latencies
  but has no effect on periodic tasks ? ...:
  - Device Drivers:
    - Graphics support:
      - Disable "Backlight & LCD device support"
      .
    - Disable "Generic Thermal sysfs driver"
    .
  . 
  
- Device Drivers:
  - Keep "Real Time Clock"
  - "Generic Dynamic Voltage and Frequency Scaling (DVFS) support" does not matter
  - sound might be ok
  .

- You probably do not need bluetooth or WLAN! (but as long as you do
  not use it it might not hurt...):
  - Device Drivers:
    - Network device support:
      - Disable "Wireless LAN"
      .
    .
  - Networking support:
    - Disable "Bluetooth subsystem support"
    - Disable "Wireless"
    .
  .

- USB: 
  - According to \c README.CONF_RMRKS from rtai-5.0.1:
    "Do not disable USB, but just any legacy support, possibly in the
    BIOS also. Once upon a time old USB was a source of high RTAI
    latencies. Now that should be legacy support."
  - If you get the error "usb: device not accepting address" add 
    \c noapic to the kernel parameter.
  .
  
.

\subsection otherconfigs Some more hints for kernel configuration parameters
Here is a list of some kernel configuration parameter that you might try to improve your
real-time perfomance (low latencies):

- In "Device drivers" keep "Multiple devices driver support (RAID and LVM)" 
  and in there keep "Device mapper support" (somehow needed for grub).

- In "Processor type and features": disabling the following seems to have an effect: 
  - Disable "Supervisor Mode Access Prevention"
  - Disable "EFI runtime service support"
  - Disable "Enable seccomp to safely compute untrusted bytecode"
  .

- NUMA (disabling seems to improve maximum latencies):
  - General setup:
    - Disabel "Memory placement aware NUMA scheduler"
  - Processor type and features: 
    - Disable "Numa Memory Allocation and Scheduler Support"
    .
  .

- HPET Timer (disabling it improves preempt jitter):
  - Device Drivers:
    - Character devices:
      - Disable "HPET - High Precision Event Timer"
      .
    .
  .

- Disable dynamic ticks (this influences Linux performance but not RTAI...):
  - General setup:
    - Timers subsystem:
      - Set "Timer tick handling" to "Periodic timer ticks" or "Idle dynticks system" (no tickless system!)
      - Deselect "Old Idle dynticks config"
      .
  - Processor type and features: 
    - Set "Timer frequency" to 1000 Hz
    - Disable "Tickless System" (in newer kernel versions this has been moved to "General setup-Timers subsystem")
    .
  .

- Disable IOMMU (no effect?):
  - Processor type and features: 
    - Disable "Old AMD GART IOMMU support"
    - Disable "IBM Calgary IOMMU support"
    .
  - Device Drivers:
    - Disable IOMMU Hardware Support
    .

- The \c lowlatency kernel image has the following settings against the \c generic one:
  - CONFIG_PREEMPT=y and CONFIG_PREEMPT_COUNT=y ("Processor type and features" -> "Preemption Model (Preemptible kernel (Low-Latency Desktop))")
  - CONFIG_HZ_1000=y and CONFIG_HZ=1000 ("Processor type and features" -> "Timer frequency")
  .

- Maybe also try:
  - CONFIG_RCU_BOOST and CONFIG_RCU_KTHREAD_PRIO
  .
.


\subsection rtaiisolcpus Isolate CPUs for real time tasks 
For further improving the RTAI performance, you might want to reserve
at least one CPU for RTAI on a multi-core machine. You can isolate
CPUs by using the kernel parameter
\code
isolcpus=0,1
\endcode
(for isolating the cores no. 0 and 1). Additional parameters are
\code
isolcpus=0,1 nohz_full=0,1 rcu_nocbs=0,1
\endcode
See the file \c /usr/local/src/rtai/README.ISOLCPUS for more details.


\subsection biosparameter Check your BIOS
Sometimes it also helps to set/disable things in the BIOS:
- Force all fans to run at full speed
- Disable CPU power saving modes
.

\subsection disablesmi Disable SMI interrupts
Finally, there are the evil SMIs. They periodically produce some long latencies. See \c
/usr/local/src/rtai/base/arch/x86/calibration/README.SMI and \c README.SMISPV for details.


\section installrelacs Setting up dynamic clamp for RELACS
You should install \c RTAI and the \c comedi drivers and library prior to
configuring RELACS, so that ./configure can detect the presence of the
\c comedi library. If you install \c RTAI and \c comedi later, simply run \c
./configure and \c make again to detect comedi and compile the
corresponding plugins for RELACS.

-# Login as a normal user
-# If you are not member of the \c iocard group (necessary for accessing the comedi devices, 
   see \ref udev), then
   \code
sudo adduser $USER iocard
   \endcode
   \note You need to log out and log in again to actually be member of that group.
-# \c cd into the RELACS top-level directory and run
   \code
./configure
   \endcode
   This should detect comedi and RTAI (see message towards the end of the output of \c configure).
-# Then get rid of any previously compiled comedi and dynamic clamp modules:
   \code
cd plugins/linuxdevices/comedi
make clean
make -j$(grep -c "^processor" /proc/cpuinfo)
cd -
cd plugins/linuxdevices/rtaicomedi
make clean
   \endcode
-# Select features of the dynamic clamp module by commenting or uncommenting the defines
at the top of the file \c plugins/linuxdevices/rtaicomedi/module/moduledef.h
or by enabling them by the --enable-dynclamp options for ./configure
(see ./configure --help for a description of all available options).
-# Implement your dynamic clamp model in the file \c plugins/linuxdevices/rtaicomedi/module/model.c .
-# Compile the dynamic clamp plugins and the kernel module
\code
cd plugins/linuxdevices/rtaicomedi
make -j$(grep -c "^processor" /proc/cpuinfo)
\endcode
-# If you get an "-mpreferred-stack-boundary" error uncomment line 4 in \c plugins/linuxdevices/rtaicomedi/module/Makefile.in and run \c make again.
-# Load the dynamic-clamp kernel module (as root):
\code
sudo module/loadmodules.sh
\endcode
-# Run RELACS in \c plugins/linuxdevices/rtaicomedi :
\code
./relacslocal
\endcode
or with the patchclamp plugins:
\code
cd plugins/patchclamp
cp relacs.cfg.dynclamp relacs.cfg
./relacslocal
\endcode
-# Possible problems are:
  - Data acquisition does not start:
    - You might not have 
      sufficient permissions for reading and writing to the 
      \c /dev/comedi* devices. For a quick fix do
      \code
sudo chmod a+rw /dev/comedi*
      \endcode
      See \ref udev for a better solution.
    - The %comedi and rtai modules are not properly loaded: check the output of \c module/loadmodules.sh and \c dmesg.
    - The %comedi device is not configured yet (should not be a problem with a recent comedi version).
    .
  - Performance is bad / RELACS regularly hangs for a few seconds / RELACS seems to be slowed down dramatically:
    - Improve your rtai kernel! See \ref configurekernel for instructions.
    .
  .
-# When developing your dynamic clamp model in \c model.c or if you dare to modify \c dynclampmodule.c, then
\code
# cd to rtaicomedi/, not rtaicomedi/module/ !
cd plugins/linuxdevices/rtaicomedi
# whenever you changed something, do:
make
sudo module/reloadmodule.sh
\endcode
Your \c model.c implementation can be tested without RTAI in the simulation mode of relacs, see \ref simulatedynclamp below.
-# If you want to load the dynamic-clamp kernel module automatically during 
the boot process, then call the \c loadmodules.sh script from the script
\c /etc/rc.local . Simply add a line like this
\code
/where/ever/the/script/is/located/loadmodules.sh
\endcode
to \c /etc/rc.local (as root).


\section configdynamicclamp Configure dynamic clamp in RELACS

Just make sure your \c relacs.cfg file has the following device sections:
\code
*Analog Input Devices
  Device1:
      plugin: [ DynClampAnalogInput, DynClampAISim ]
      device: /dev/comedi0
      ident : ai-1

*Analog Output Devices
  Device1:
      plugin: [ DynClampAnalogOutput, DynClampAOSim ]
      device: /dev/comedi0
      ident : ao-1
\endcode

\subsection inputtraces  Input traces 
As usual, input traces can be assigned to channels
of the analog input device. All the input traces the dynamic clamp
model requires (its \c inputNames) must be available.

The dynamic clamp plugins provide some additional input traces. They can be accessed like
normal analog input traces, but the channel nummber needs to be set to 1000 or larger.
The following three types of additional inputs are supported:
- Additional inputs as defined by the dynamic clamp model via its \c paramInputNames.
- Timing measurements, if they are enabled in moduledef.h:
  - \c Interval : the full period of each cycle of the dynamic clamp loop (always available)
  - \c AI-time : the time required by the analog input part
  - \c AI-acquisition-time : the time required by reading in a single analog input channel
  - \c AI-conversion-time : the time required to convert the read in value
  - \c AO-time : the time required by the analog output part
  - \c Model-time : the time required for calling computModel()
  - \c Wait-time : the time rt_task_wait_period() waits for the next period
  .
  all times are measured in seconds.
- For each analog output trace the dynamic clamp model is using (its \c outputNames)
  the following input traces are available:
  - \c Stimulus-xxx contains the stimulus a RePro wrote to this channel,
  - \c Model-xxx contains the value the model computed, and
  - \c Total-xxx contains the total requested output for this channel, i.e. Stimulus-xxx plus Model-xxx.
  - \c Injected-xxx contains the total output for this channel as it is written to the analog output.
    This equals \c Total-xxx multiplied by a possible correction factor and is only available with ENABLE_SYNCSEC
  .
  \c xxx is the name of the analog output trace. If the Injected or Total output exceeds the limits of the 
  maximum range of the data acquisition board, they are clipped to the minimum or maximum possible values.

\subsection outputtraces Output traces 
As usual, output traces can be assigned to channels
of the analog output device. All the output traces the dynamic clamp
model requires (its \c outputNames) must be available.

Additional output traces as defined by the dynamic clamp model via its
\c paramOutputNames can be accessed like normal analog output traces by
their name.


\section simulatedynclamp Dynamic clamp simulation 
You can run the dynamic clamp in the relacs simulation mode as well.
This is in particular handy when it comes to testing your \c model.c
implementation without RTAI.

The relacs::DynClampAISim and relacs::DynClampAOSim modules do the trick.

Whenever you change \c model.c you need to recompile the
\c DynClampAISim and \c DynClampAOSim modules by calling \c make in the 
\c plugins/linuxdevices/rtaicomedi directory.
\code
cd plugins/linuxdevices/rtaicomedi
make
\endcode

Then call \c relacs with the \c -3 option
\code
./relacslocal -3
\endcode
and enjoy the simulation.

*/
