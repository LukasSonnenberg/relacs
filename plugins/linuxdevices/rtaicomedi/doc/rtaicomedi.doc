/*!
\mainpage RTAI-comedi Relacs Plugins

\brief Plugins for dynamic clamp based on RTAI and comedi.


\section rtaicomedicontent Content
- \ref rtaicomediintro
- \ref installation
  - \ref quickinstall
  - \ref installrtaikernel
  - \ref installnewlib
  - \ref installrtai
  - \ref testrtai
  - \ref configurekernel
  - \ref installcomedi
  - \ref udev
  - \ref installrelacs
  - \ref kernelmessages
  .
- \ref configdynamicclamp
- \ref simulatedynclamp
- \ref rtailinks


\section rtaicomediintro Introduction

For using dynamic clamp, i.e. some realtime computation, as it is
implemented by the DynClampAnalogInput and DynClampAnalogOutput
plugins, you need to install an RTAI-patched real-time linux
kernel, RTAI kernel modules, and comedi, as described in the following
sections.

You can use a script for installing RTAI as explained in the next
section \ref quickinstall.

Alternatively, you can do the installation manually as explained in
the sections \ref installrtaikernel, \ref installnewlib, \ref
installrtai, \ref testrtai, and \ref installcomedi .

In either case, continue with building the dynamic clamp module of
relacs as explained in \ref installrelacs .

If you only want to simulate a dynamic clamp, then go on and read
\ref simulatedynclamp .


\section installation Installation

\subsection quickinstall Installation script

The \c makertaikernel.sh script in \c scripts/ executes all the
commands as explained in the following sections to download and build an RTAI-patched
linux kernel, the newlib library, and the RTAI and comedi kernel modules.

-# From the relacs source tree go to
   \code
cd plugins/linuxdevices/rtaicomedi/scripts
   \endcode

-# Start with selecting and downloading an RTAI source (-r option or RTAI_DIR variable, see \c ./makertaikernel \c help for options):
   \code
sudo ./makertaikernel download rtai
   \endcode

-# Check for available RTAI patches:
   \code
sudo ./makertaikernel.sh info rtai
   \endcode
   Select a Linux kernel and the corresponding RTAI patch.

-# Modify the variables at the top of the script or set them before executing makertaikernel.sh,
   in particular the \c LINUX_KERNEL, \c RTAI_PATCH, and \c KERNEL_PATH variables to match
   the kernel version, rtai patch you want to use, and the directory
   where to build the linux kernel (you need up to 2 GB space there for a kernel 
   with most device drivers disabled (e.g. via localmodconf) or 5-10GB for a full kernel).

-# You may want to start out with a kernel
   configuration of a kernel image from your linux distribution
   closest to the kernel version you selected. On a Debian-based
   system install a matching kernel by executing
   \code
sudo apt-get install linux-image-4.4.0-79-lowlatency
   \endcode
   for example, and boot into this kernel. Then \c makertaikernel.sh
   will use this kernel's configuration and deselect all kernel
   modules that are not used (localmodconfig).
   If the version of the running kernel does not  match the one 
   of the selected kernel (major or minor version number differ), 
   localmodconfig is not applied, resulting
   in a much larger kernel (takes much more time to compile).

-# Then run
   \code
sudo ./makertaikernel.sh
   \endcode

   This will download the required sources (takes a while...) and
   build the kernel using the kernel configuration of the running
   kernel (takes even more time...). With the \c-c flag you can
   provide a different kernel configuration (see \c makertaikernel.sh
   \c help for details).

-# You will get the menu for configuring the kernel. See \ref compilekernel
   step 5 for instructions.

-# Reboot into the new kernel, e.g. by running
   \code
sudo ./makertaikernel.sh reboot
   \endcode
   Once you rebooted in the RTAI kernel run some tests by invoking
   \code
sudo ./makertaikernel.sh test
   \endcode
   to run the "kern" tests or
   \code
sudo ./makertaikernel.sh test all
   \endcode
   to run the kern, kthreads, and user tests.
   The result of the tests is written into the file
   latencies-3.14.17-rtai-XXX-NAME-QUALITY and the corresponding
   kernel configuration is saved in
   config-3.14.17-rtai-XXX-NAME_QUALITY in the current directory. RTAI
   is replaced by your choice of RTAI source (e.g. magma, rtai-4.1, etc), 
   XXX is replaced by a number, NAME and QUALITY are short
   strings describing your kernel configuration and the test
   performance that you can enter after the test.

   See \ref testrtai for details regarding the test results and \ref configurekernel
   for troubleshooting and how to improve the real time performance.

-# If you did not start out with a kernel version matching the version
   of your RTAI-patched kernel, then before you go on with improving
   the kernel configuration run
   \code
sudo ./makertaikernel.sh -c mod
   \endcode
   in order to deselect all unused kernel modules from compilation. 
   This speeds up the following kernel builds dramatically!

-# If the test results are not good, then build a new version of the kernel
   with a different configuration (see \ref configurekernel for details):
   \code
sudo ./makertaikernel.sh -n rtai2 reconfigure
   \endcode
   reboot into the \c rtai1 kernel, test the new kernel, reconfigure again yet another kernel (with a different name):
   \code
sudo ./makertaikernel.sh -n rtai2 test
sudo ./makertaikernel.sh -n rtai1 reconfigure
   \endcode
   reboot, and do the same with the right kernel names:
   \code
sudo ./makertaikernel.sh -n rtai1 test
sudo ./makertaikernel.sh -n rtai2 reconfigure
   \endcode

   Note that \c makertaikernel \c reconfigure will first uninstall an already existing kernel with the same name.

   You can recreate this kernel or use this kernel's configuration for
   further modifications by specifying the kernel configuration file
   saved by \c makertaikernel \c test using the \c-c option
   \code
sudo ./makertaikernel.sh -n rtai1 -c config-3.14.17-rtai-002-nousb-good reconfigure
   \endcode
-# Once you are satisified, continue with \ref installrelacs .

For further options of the \c makertaikernel script see
\code
./makertaikernel.sh help
\endcode
To show some information about your machine, RTAI patches, grub menue, etc. run
\code
./makertaikernel info
\endcode

The following sections describe in detail how to compile and install
an RTAI-patched linux kernel, newlib, RTAI, and comedi, if you do not use
the \c makertaikernel.sh script.


\subsection installrtaikernel  Linux kernel and RTAI patch

\subsubsection patchkernel Download RTAI, a linux kernel, and patch the kernel

-# Login as root and cd into \c /usr/local/src:
\code
sudo su  # or su
cd /usr/local/src
\endcode
-# Download the latest RTAI (http://www.rtai.org) version into \c
/usr/local/src :
   - Either the latest RTAI release (check the RTAI homepage at http://www.rtai.org)
     \code
wget https://www.rtai.org/userfiles/downloads/RTAI/rtai-4.1.tar.bz2
tar xf rtai-4.1.tar.bz2
ln -sfn rtai-4.1 rtai
     \endcode
   - or the current development version from the official RTAI cvs repository
     \code
cvs -d:pserver:anonymous@cvs.gna.org:/cvs/rtai co magma
ln -sfn magma rtai
     \endcode
     (I got this running with the hal-linux-3.14.17-x86-6x.patch on an Intel i7 as of April 7, 2015)
   - or from Shahbaz Youssefi's RTAI clone on github:
     \code
git clone https://github.com/ShabbyX/RTAI.git
ln -sfn RTAI rtai
    \endcode
   .
\note Read the \c rtai/README.INSTALL and \c https://github.com/ShabbyX/RTAI/blob/master/README.INSTALL file!
-# Find out your CPU architecture:
\code
uname -m
\endcode
-# Check for available patches. Get a list of all patches for all architectures:
\code
find /usr/local/src/rtai/base/arch/ -name '*.patch' | sort
\endcode
The most recent patches for both intel and amd 32 and 64-bit systems (x86_64 and i386 architectures)
are in the \c x86/ directory.
Decide for a patch, and remember its version number: \c hal-linux-<kernel-version>-*.patch .
If you got RTAi from cvs then the patches with an "x" at the end should be preferred.
-# Download a 'vanilla' kernel, e.g. \c linux-<kernel-version>.tar.xz from http://www.kernel.org
  to \c /usr/src and unpack the kernel:
\code
cd /usr/src
wget https://www.kernel.org/pub/linux/kernel/v3.x/linux-3.14.17.tar.xz
tar xf linux-3.14.17.tar.xz
mv linux-3.14.17 linux-3.14.17-rtai
ln -sfn linux-3.14.17-rtai linux
\endcode
-# Patch the kernel (use the patch file that matches the downloaded kernel)
\code
cd /usr/src/linux
patch -p1 < /usr/local/src/rtai/base/arch/x86/patches/hal-linux-3.14.17-x86-6x.patch
\endcode
-# Configure, compile, and install the kernel as described in the following section.


\subsubsection compilekernel Compile the rtai-patched linux kernel

-# Make sure the \c make, \c gcc, \c libncurses-dev, and \c zlib1g-dev packages are installed:
   \code
apt-get -y install make gcc libncurses-dev zlib1g-dev
   \endcode
   on a Debian system also install the kernel-package
   \code
apt-get -y install kernel-package
   \endcode

-# Clean up the kernel:
   \code
cd /usr/src/linux
make mrproper
make-kpkg clean  # on Debian system only
   \endcode

-# There are basically two strategies for getting a good real-time
   kernel. The initially simpler approach is to start out with the
   configuration of your running default kernel and then disable what
   you do not need and what might deteriorate the real-time
   performance.  This approach most likely gives a running kernel, but
   also might result in bad or not so good real-time
   performance. Alternatively, I recommend to consider the approach
   described in \c https://github.com/ShabbyX/RTAI/blob/master/README.INSTALL . 
   Here you start out with a minimalistic kernel configuration and add
   the few (!) driver modules that you really need on your machine. The
   kernel will compile much faster and chances are good to get good
   real-time performance.

   In the following the first approach to configure a real-time kernel
   is described:

   Reuse your current kernel configuration:
   \code
cp /boot/config-`uname -r` .config
make olddefconfig
   \endcode
   Hit \c enter to all the (probably many) questions. If the
   configuration file is from the default kernel of your
   distribution this results in a large kernel that takes a long
   time to compile, since all device drivers get compiled, of which
   you only need a very few.

   Possible variations on this theme are:
   - Use the kernels default configuration:
     \code
make defconfig
     \endcode
   - Try to start out with the -rt or -lowlatency kernels and take the \c .config file from there
   .

   In addition you might want to disable kernel modules that are not
   used on your machine. For this to work best you need to run in the
   kernel from which you took the configuration:
   \code
yes "" | make localmodconfig
   \endcode
   This gives a smaller kernel that is compiled much faster.

   Even better: run
   \code
lsmod
   \endcode
   and check for modules that are not used or that you do not need.
   Unload them with
   \code
modprobe -r module1 module2 ...
   \endcode
   and run
   \code
yes "" | make localmodconfig
   \endcode
   again.
   
   The aim is to throw everything away that you do not really need and hope that
   this improves the performance of your rtai kernel. See \ref configurekernel
   for some hints.

-# The following steps 4. to 6. describe the elegant way to compile a linux kernel 
   on a Debian system using the kernel-package.
   You get a nice \c .deb file with the compiled kernel
   that you can install on other machines as well.
   See http://wiki.linuxcnc.org/cgi-bin/wiki.pl?Debian_Lenny_Compile_RTAI for more details.

   The normal way to compile a linux kernel is described starting at step 7. below.

-# Debian system: configure and build the kernel
   \code
export CONCURRENCY_LEVEL=$(grep -c "^processor" /proc/cpuinfo)  # the number of CPU cores you have
make-kpkg --initrd --append-to-version -rtai --revision 1.0 --config menuconfig kernel-image # kernel-headers kernel-source
   \endcode
   In the kernel configuration dialog you should check the following settings:
   - General setup: 
     - Make sure that "Local version" is empty in case you are using \c make-kpkg (Debian system).
       Otherwise set "Local version" to "-rtai".
     - Disable "Enable sytem-call auditing support"
     - Disable "Configure standard kernel features (expert users)"
     .
   - Processor type and features: 
     - Select "Symmetric multi-processing support" (SMP) if you have a multiprocessor machine, otherwise (uniprocessor system, UP) deselect it
     - Select your "Subarchitecture Type" (PC-Compatible) - this option does not exist for newer kernels
     - Select the right Processor family (you find the name of your processor by looking at \c /proc/cpuinfo,
       check \c "help" to find out, which Processor family you have to select)
     - Set the "Maximum numbers of CPUs" to the number of cores you have in your machine (see /proc/cpuinfo)
     - Disable "SMT (Hyperthreading) scheduler support"
     - Disable "Multi-core scheduler support"
     - Select "Preemption Model (Preemptible kernel (Low-Latency Desktop))"
     - Select "Interrupt pipeline"
     - "I-pipe legacy interface": enable for rtai-4.1 (and earlier?), disable for current cvs.
   - Power management and ACPI options:
     - Disable everything except for:
     - Enable "ACPI (Advanced Configuration and Power Interface) Support"
       - Disable everything execpt for:
       - Select "Power Management Timer Suppport" (if available)
       .
     - Disable "CPU Frequency scaling" (\c CPU_FREQ)
     - Disable "CPU idle PM support" (\c CPU_IDLE)
     .
   - Device Drivers:
     - Staging drivers:
       - Deselect "Data acquisition support (comedi)"
       .
     .
   - Kernel hacking: disabling debugging makes the kernel much smaller. So unless you know that you need it disable it.
     - Compile-time checks and compiler options:
       - Disable "Compile the kernel with debug info"
     .
     - Disable "Kernel debugging"
     - Disable "Magic SysRq key"
     - Disable "Early printk via EHCI debug port" (unless you still have EHCI USB 2.0 enabled)
     - Disable "Allow gcc to uninline functions marked 'inline'"
   .
   - Disable "Virtualization" if possible unless you know that you need it.
   .
   Leave the configuration dialog by pressing "Exit" until you are asked "Save kernel config?".
   Select "Yes".

   Then the new kernel is being compiled - be patient.

-# Install the kernel
   \code
dpkg -i ../linux-image-3.14.17-rtai_1.0_amd64.deb # ../linux-headers-3.14.17-rtai_1.0_amd64.deb
   \endcode

   Then modify the boot menu as described in step 9 if necessary and reboot (step 10).

   Note: To uninstall the rtai kernel do 
   \code
apt-get remove linux-image-3.14.17-rtai
   \endcode
   This removes the files in \c /boot and the modules in \c /lib/modules .

-# Non-Debian System: Here is the non-Debian way to compile a linux kernel.

   First, you configure your kernel by calling
   \code
make menuconfig
   \endcode
   Use the settings described in step 5.

   Then compile and install the kernel
   \code
export MAKEFLAGS=" -j$(grep -c "^processor" /proc/cpuinfo)"
make
make modules
make modules_install
make install
  \endcode
  This takes quite a while.

-# If necessary, install third party kernel modules as well,
   like for example the ones for your graphics board.
   (The following is probably outdated) For your nvidia graphics board, download the driver from
   http://www.nvidia.com/Download/index.aspx?lang=en-us.
   Install it by calling
   \code
   sh NVIDIA-Linux-x86_64-190.42-pkg2.run -k 3.14.17-rtai -K
   \endcode
   (replace 3.14.17-rtai by the name of the kernel where you want to install the nvidia driver,
   i.e. the string '\c uname \c -r' would return if that kernel is running).

-# Configure your boot loader by editing the file \c /etc/default/grub (for \c grub \c v2):
   - To get the boot menu that you need to select the kernel you want to boot
     you should for example unset the \c GRUB_HIDDEN_TIMEOUT and set the
     \c GRUB_TIMEOUT appropriately in that file. For example:
     \code
#GRUB_HIDDEN_TIMEOUT=0
#GRUB_HIDDEN_TIMEOUT_QUIET=true
GRUB_TIMEOUT=5
     \endcode

   - If you do not like that grub puts your rtai kernel into a subsection called
     'Previous linux versions', then make sure you have a line
     \code
GRUB_DISABLE_SUBMENU=y
     \endcode

     Older version do not support this option, for a workaround do
     \code
cd /etc/grub.d/
sudo cp 10_linux 11_linux
sudo chmod a-x 10_linux
     \endcode
     Then comment out the following lines in \c
     /etc/grub.d/11_linux to get rid of the submenu in grub:
     \code
#  if [ "$list" ] && ! $in_submenu; then
#    echo "submenu \"Previous Linux versions\" {"
#    in_submenu=:
#  fi
done

#if $in_submenu; then
#  echo "}"
#fi
     \endcode
     If you apply these changes to \c 10_linux directly, after
     rebooting the changes in \c 10_linux will disappear. I have no
     idea why...

   - With disabled acpi your rtai-patched linux kernel might not properly reboot. Try
     \code
GRUB_CMDLINE_LINUX_DEFAULT="quiet splash reboot=triple"
     \endcode
     See \c /usr/src/linux/Documentation/x86/x86_64/boot-options.txt
     for more options for the reboot parameter.

   - You can set the GRUB_DEFAULT variable to
     tell grub which kernel to boot by default. It can be a integer
     number (first kernel is 0), or something like 2>0 if your kernel
     is in a submenu, or, instead of the integers, you can put in the grub menu entry.
     Check
     \code
sed -n -e "/menuentry '/{s/.*'\\(.*\\)'.*/\\1/;p}" /boot/grub/grub.cfg
     \endcode
     for all available menu entries.

     When testing rtai kernels it might be sensible to set the default kernel to one that
     is working.

     See also \c man \c grub-set-default .
   .
   After changing \c /etc/default/grub simply run
   \code
update-grub
   \endcode
   to apply the changes.
   The output of \c update-grub should mention your new kernel image.

    You can tell grub to use your new rtai kernel after the next reboot by calling
    \code
sudo grub-reboot "Linux Mint 17 KDE 64-bit, 3.14.17-rtai1 (/dev/sda1)"
    \endcode
    See http://statusq.org/archives/2012/10/24/4584/ for more interesting options.

-# Reboot the computer into the new kernel:
\code
reboot
\endcode
If this fails you need to improve the configuration of the kernel. See \ref configurekernel for some hints.


\subsection installnewlib Newlib library for mathematical functions

For dynamic clamp having math functions available in the kernel is quite handy. For this RTAI needs
on a 64-bit system the math library from the newlib library as a replacement for the standard \c libm.a .
As root:
\code
cd /usr/local/src
mkdir newlib
cd newlib
cvs -z 9 -d :pserver:anoncvs@sourceware.org:/cvs/src login  # password: anoncvs
cvs -z 9 -d :pserver:anoncvs@sourceware.org:/cvs/src co newlib
mkdir install
cd src/newlib
./configure --prefix=/usr/local/src/newlib/install --disable-shared CFLAGS="-O2 -mcmodel=kernel"
make
make install
\endcode


\subsection installrtai RTAI kernel modules

-# Make sure that you are root and you are really running your RTAI kernel!
   You can check with
   \code
uname -r
   \endcode

-# Change to the RTAI directory
   \code
cd /usr/local/src/rtai
   \endcode
-# In case you downloaded RTAI from https://github.com/ShabbyX/RTAI,
   you need to generate the configure script and makefiles first:
   \code
./autogen.sh
   \endcode
-# Configure RTAI by calling
   \code
make menuconfig
   \endcode
   Check the following settings:
   - General
     - "Installation directory": should be set to \c /usr/realtime
     - "Linux source tree": must be set to \c /usr/src/linux
     - "RTAI Documentation": deselect all documentation. You nevertheless find api documentation in \c /usr/realtime/share/doc
     - Select "Build RTAI testsuite"
     - Disable "Enable source compatibility mode"
     - "Inlining mode of user-space services": select "Eager inlining"
   - Machine
     - Select "Enable FPU support
     - "Number of CPUs": set to the right value.
       If in doubt, look into the file \c /proc/cpuinfo or run
       \code
grep -c "^processor" /proc/cpuinfo
       \endcode
     .
   - Base system
     - Other features
       - Select "Mathfuns support in kernel"
       - 1 - NEWLIB (default), 2 - UCLIB, 3 - GLIBC: set to (1)
       - The installation directory of your chosen libm.a: set to "/usr/local/src/newlib/install/lib" (old, pre Oct 2016) or "/usr/local/src/newlib/install/x86_64/lib" (new) - check it with
         \code
find /usr/local/src/newlib/install -name 'libm.a'
         \endcode
       .
     .
   - Add-ons
     - "Real Time COMEDI support in user space": leave unselected
     .
   .
   Then exit and save configuration.
   Watch the output while RTAI is configured for possible warnings and errors.
   In case this fails, you should check and/or edit the file \c .rtai_config
   and run \c .configure manually.

-# Compile and install
   \code
make
make install
   \endcode
   Known issues:
     - In case you get an error like: "-mpreferred-stack-boundary=3 is not between 4 and 12"
       Read http://mail.rtai.org/pipermail/rtai/2014-October/026542.html
     - In case you get an error like "/usr/include/features.h:323:26:
       fatal error: bits/predefs.h: No such file or directory" install
       the gcc-multilib package
       \code
apt-get install gcc-multilib
       \endcode
     - In case you get an error like
       "../../../base/include/asm/rtai_leds.h:24:20: error: asm/io.h:
       No such file or directory" then delete the "#include
       <asm/io.h>" line in the specified file and call \c make again.
     - (Old) rtai_lxrt errors:

       - If you get error messages like
         "../../../base/sched/liblxrt/.libs/liblxrt.so: undefined
         reference to `pthread_create'", i.e. undefined references to
         various pthread functions, then open \c
         base/sched/liblxrt/GNUmakefile in you favourite editor, find
         the line containing 'liblxrt_la_LIBADD' and add "-lpthread"
         to it so that this line looks like
         \code
liblxrt_la_LIBADD = -lpthread
         \endcode

       - In case of an error message like
         "../../../../base/include/rtai_lxrt.h:655:11: error:
         ‘CLONE_VM’ undeclared (first use in this function)" open \c
         base/include/rtai_lxrt.h in you favorite editor and add the
         line
         \code
#include <linux/sched.h>
         \endcode
         right before the line "#include <rtai_sched.h>"
       .
       In both cases do
       \code
cd base/sched/liblxrt
make clean
cd -
make
       \endcode


\subsection testrtai Testing performance of RTAI kernel

Testing your RTAI patched kernel is crucial for a good real-time performance!

-# Test RTAI by loading some modules:
   \code
cd /usr/realtime/modules
insmod rtai_hal.ko
insmod rtai_sched.ko
insmod rtai_fifos.ko
insmod rtai_math.ko
   \endcode

   If this fails:

   First, check the output of
   \code
dmesg
   \endcode
   for some hints.

   Try adding one or several of the advanced configuration and power
   interface (ACPI) or advanced programmable interrupt controller
   (APIC) options, \c acpi=off, \c pci=noacpi \c noapic \c nolapic \c
   lapic , to the kernel parameter in the \c kernel line of the \c
   grub menu in \c /boot/grub/menu.lst (\c grub \c v1) or to the \c
   GRUB_CMDLINE_LINUX variable in \c /etc/defaults/grub .  Recompile
   and install RTAI (make clean && make && make install && depmod -a).

   After restart, check for the number of CPUs in \c /proc/cpuinfo - they might be reduced by these parameters!

-# Run the RTAI latency test
   \code
cd /usr/realtime/testsuite/kern/latency
./run
   \endcode
   The output looks like this:
   \code
RTAI Testsuite - KERNEL latency (all data in nanoseconds)
RTH|    lat min|    ovl min|    lat avg|    lat max|    ovl max|   overruns
RTD|         60|         60|        141|       1040|       1040|          0
RTD|         61|         60|        126|        372|       1040|          0
RTD|         66|         60|        127|        364|       1040|          0
RTD|         66|         60|        128|        748|       1040|          0
RTD|         92|         60|        129|        719|       1040|          0
   \endcode
   If you have overruns, or the maximum latencies "lat max" are too
   high (<1000 ns is good, <5000 is kind of ok, longer than 10000 ns is really bad)
   then you need to improve you kernel by disabling some bad device drivers (see below).

   Also run the switch test:
   \code
cd /usr/realtime/testsuite/kern/switches
./run
   \endcode
   The output looks like this:
   \code
Apr  7 16:08:45 knifefish kernel: [  178.940333] 
Apr  7 16:08:45 knifefish kernel: [  178.940333] Wait for it ...
Apr  7 16:08:45 knifefish kernel: [  178.959986] 
Apr  7 16:08:45 knifefish kernel: [  178.959986] 
Apr  7 16:08:45 knifefish kernel: [  178.959986] FOR 10 TASKS: TIME 5 (ms), SUSP/RES SWITCHES 40000, SWITCH TIME (INCLUDING FULL FP SUPPORT) 145 (ns)
Apr  7 16:08:45 knifefish kernel: [  178.959988] 
Apr  7 16:08:45 knifefish kernel: [  178.959988] FOR 10 TASKS: TIME 6 (ms), SEM SIG/WAIT SWITCHES 40000, SWITCH TIME (INCLUDING FULL FP SUPPORT) 158 (ns)
Apr  7 16:08:45 knifefish kernel: [  178.959990] 
Apr  7 16:08:45 knifefish kernel: [  178.959990] FOR 10 TASKS: TIME 7 (ms), RPC/RCV-RET SWITCHES 40000, SWITCH TIME (INCLUDING FULL FP SUPPORT) 186 (ns)
   \endcode
   The reported switching times should be well below 1000ns.

   Finally, there is the "preempt" test:
   \code
cd /usr/realtime/testsuite/kern/preempt
./run
   \endcode

-# To really check out the performance of the kernel you should run the tests 
   under heavy load. That is, run some processes like
   - at least one "ping -f somewhere";
   - a "ping -f localhost";
   - a "top" on alpha screen and one on an X screen;
   - a "while "true"; do ls -lR / >list; done"
   - a "while "true"; cat /proc/interrupts; done"
   - dd if=/dev/hda2 of=/dev/hda3 bs=1000k &  # /dev/hda3 needs to be a free partition that is at least as large as /dev/hda2!!!
   .

-# If your test results are not good, then you need to reconfigure
   your kernel, probably disabling some devices, compile and install the kernel again,
   and compile and install rtai again. See \ref configurekernel below for hints.

-# For further improving the RTAI performance, you might want to reserve at least one CPU
   for RTAI on a multi-core machine. You can isolate CPUs by using the kernel parameter
   \code
isolcpus=0,1
   \endcode
   (for isolating the cores no. 0 and 1).
   See the file \c /usr/local/src/rtai/README.ISOLCPUS for more details.


\subsection configurekernel Improve the configuration of the RTAI-patched kernel

To get a low latency kernel you usually need to improve your kernel
configuration.  The main culprits are some devices and their
drivers. Which ones are bad usually depends on your specific machine.

See \c https://www.rtai.org/userfiles/documentation/documents/RTAI_User_Manual_34_03.pdf,
\c https://github.com/ShabbyX/RTAI/blob/master/README.INSTALL, and
\c /usr/local/src/rtai/README.CONF_RMRKS
for some hints.  This is the art of creating a good real-time kernel...

\subsubsection powersavingmodes Disable CPU power saving modes
Most importantly, for newer CPUs like Intel i5 and Intel i7 CPUs,
disabling CPU power saving modes improves real-time performance dramatically:
- Add the kernel parameters \c processor.max_cstate=1 \c idle=poll .
  See \ref kernelparamhints on how to set kernel parameter.
- The cstates can also be dynamically controlled by writing the
  maximum allowable latency in microseconds (as an 32-bit(?) \c int, not as
  text) to the file \c /dev/cpu_dma_latency . Writing a zero keeps the
  system in \c cstate=0.
.
Monitor cstates:
- Check cpu idle driver and intel max_cstate setting with
  \code
cat /sys/devices/system/cpu/cpuidle/current_driver
cat /sys/module/intel_idle/parameters/max_cstate
  \endcode
- Run \c i7z or \c powertop (as root) to see cstates and CPU temperatures.
.
See also \c Documentation/power/pm_qos_interface.txt in your kernel
source tree in \c /usr/src/linux and
http://stackoverflow.com/questions/12111954/context-switches-much-slower-in-new-linux-kernels


\subsubsection linuxdma Disable DMA
Disable all DMA transfers by setting kernel parameter \c libata.dma=0.
See \ref kernelparamhints on how to set kernel parameter.


\subsubsection disabledevices Disable device drivers you do not need
A good strategy is to disable as many as possible device drivers.
See
\code
lsmod
\endcode
for the currently loaded kernel modules. When configuring the kernel
you can hit '\', enter a search term (the module name) and you get a 
list of matching configuration parameters.

Devices to look out are:
- Disable DRM:
  - Device Drivers:
    - Graphics support:
      - Disable "Direct Rendering Manager"
      .
    .
  .

- Check video cards and graphic acceleration

- Disabling the thermal sysfs driver is sometimes great for latencies
  but has no effect on periodic tasks ? ...:
  - Device Drivers:
    - Graphics support:
      - Disable "Backlight & LCD device support"
      .
    - Disable "Generic Thermal sysfs driver"
    .
  . 
  
- Device Drivers:
  - Keep "Real Time Clock"
  - "Generic Dynamic Voltage and Frequency Scaling (DVFS) support" does not matter
  - sound might be ok
  .

- You probably do not need bluetooth or WLAN! (but as long as you do
  not use it it might not hurt...):
  - Device Drivers:
    - Network device support:
      - Disable "Wireless LAN"
      .
    .
  - Networking support:
    - Disable "Bluetooth subsystem support"
    - Disable "Wireless"
    .
  .

- According to \c README.CONF_RMRKS from rtai-5.0.1:
  "Do not disable USB, but just any legacy support, possibly in the
  BIOS also. Once upon a time old USB was a source of high RTAI
  latencies. Now that should be legacy support."
.

\subsubsection otherconfigs Some more hints for kernel configuration parameters
Here is a list of some kernel configuration parameter that you might try to improve your
real-time perfomance (low latencies):

- In "Device drivers" keep "Multiple devices driver support (RAID and LVM)" 
  and in there keep "Device mapper support" (somehow needed for grub).

- In "Processor type and features": disbling the following seems to have an effect: 
  - Disable "Supervisor Mode Access Prevention"
  - Disable "EFI runtime service support"
  - Disable "Enable seccomp to safely compute untrusted bytecode"
  .

- NUMA (disabling seems to improve maximum latencies):
  - General setup:
    - Disabel "Memory placement aware NUMA scheduler"
  - Processor type and features: 
    - Disable "Numa Memory Allocation and Scheduler Support"
    .
  .

- HPET Timer (disabling it improves preempt jitter):
  - Device Drivers:
    - Character devices:
      - Disable "HPET - High Precision Event Timer"
      .
    .
  .

- Disable dynamic ticks (this influences Linux performance but not RTAI...):
  - General setup:
    - Timers subsystem:
      - Set "Timer tick handling" to "Periodic timer ticks" or "Idle dynticks system" (no tickless system!)
      - Deselect "Old Idle dynticks config"
      .
  - Processor type and features: 
    - Set "Timer frequency" to 1000 Hz
    - Disable "Tickless System" (in newer kernel versions this has been moved to "General setup-Timers subsystem")
    .
  .

- Disable IOMMU (no effect?):
  - Processor type and features: 
    - Disable "Old AMD GART IOMMU support"
    - Disable "IBM Calgary IOMMU support"
    .
  - Device Drivers:
    - Disable IOMMU Hardware Support
    .

- The \c lowlatency kernel image has the following settings against the \c generic one:
  - CONFIG_IRQ_FORCED_THREADING_DEFAULT=y
  - CONFIG_PREEMPT_RCU=y
  - deselect CONFIG_OPTPROBES=y
  - Instead of CONFIG_INLINE_{SPIN|READ|WRITE}_UNLOCK{|_IRQ}=y only CONFIG_UNINLINE_SPIN_UNLOCK=y
  - CONFIG_PREEMPT=y and CONFIG_PREEMPT_COUNT=y
  - CONFIG_HZ_1000=y and CONFIG_HZ=1000
  - deselect CONFIG_DRM_I810=m
  - deselect CONFIG_DEBUG_PREEMPT and CONFIG_PREEMPT_TRACER
  .
.

\subsubsection kernelparamhints Kernel parameter
In addition, there are several interesting kernel parameter:
- check out https://gitlab.eurecom.fr/oai/openairinterface5g/wikis/OpenAirKernelMainSetup for more hints on disabling power-management and frequency scaling stuff
- Check frequency scaling of CPUs with \a cpufreq-info from the \c cpufrequtils package.
- Also check out "nohalt" kernel parameter (Documentation/kernel-parameters.txt).
- For scheduling interrupts read Documentation/timers/NO_HZ.txt
- Advanced configuration and power interface (ACPI): \c acpi=off and/or \c pci=noacpi .
- Advanced programmable interrupt controller (APIC): \c noapic and/or \c nolapic and/or \c lapic
- Disable the intel_idle module. Alternatively you can set \c intel_idle.max_cstate=0 . This is taken care of by the disabled "CPU Idle" in "Power management and ACPI options".
.
You can set kernel parameters during startup by hitting 'e' in the \c
grub menu and then add them to the \c kernel line. For applying the
kernel parameter permanently add them in \c /boot/grub/menu.lst (\c
grub \c v1) or to the \c GRUB_CMDLINE_LINUX variable in \c
/etc/defaults/grub and run \c update-grub.

After restart, check for the number of CPUs in \c /proc/cpuinfo - they might be reduced if you disabled too much ACPI!

\subsubsection biosparameter Check your BIOS
Sometimes it also helps to set/disable things in the BIOS:
- Force all fans to run at full speed
- Disable CPU power saving modes
.

\subsubsection disablesmi Disable SMI interrupts
Finally, there are the evil SMIs. They periodically produce some long latencies. See \c
/usr/local/src/rtai/base/arch/x86/calibration/README.SMI and \c README.SMISPV for details.



\subsection installcomedi Comedi data acquisition driver

Comedi (linux control and measurement device interface) provides
hardware drivers to many data acquisition boards with a common library
interface.  The RELACS rtaicomedi plugins access data acquisition
boards by means of the comedi kernel library.  For general information
about comedi and a list of supported devices see http://www.comedi.org
.

For an RTAI kernel you definitely have to install the comedi drivers 
yourself according to the following instructions:

-# Login as root
-# Remove all comedi modules:
\code
for i in $(lsmod | grep "^comedi" | tail -n 1 | awk '{ m=$4; gsub(/,/,"\n",m); print m}' | tac); do
    modprobe -r $i && echo "removed $i"
done
\endcode
-# Remove all installed comedi stuff:
\code
apt-get purge libcomedi-dev libcomedi0
rm -r /lib/modules/`uname -r`/kernel/drivers/staging/comedi
depmod -a
\endcode
-# Install comedi from source.
Here are all commands that you can throw into a shell to completely install comedi:
\code
# install all required packages:
apt-get -y install gcc g++ git autoconf automake libtool bison flex libgsl0-dev libboost-program-options-dev

# download comedi sources:
cd /usr/local/src
git clone https://github.com/Linux-Comedi/comedi.git
git clone https://github.com/Linux-Comedi/comedilib.git
git clone https://github.com/Linux-Comedi/comedi_calibrate.git
rm -r /lib/modules/`uname -r`/kernel/drivers/staging/comedi

# comedi:
cd /usr/local/src/comedi
cp /usr/realtime/modules/Module.symvers comedi/
./autogen.sh
PATH="$PATH:/usr/realtime/bin"
./configure --with-linuxdir=/usr/src/linux --with-rtaidir=/usr/realtime
make -j$(grep -c "^processor" /proc/cpuinfo)
make install
depmod -a
cp /usr/local/src/comedi/comedi/Module.symvers /lib/modules/`uname -r`/comedi/
cp /usr/local/src/comedi/include/linux/comedi.h /usr/include/linux/
cp /usr/local/src/comedi/include/linux/comedilib.h /usr/include/linux/

# comedilib:
cd /usr/local/src/comedilib
./autogen.sh
./configure --prefix=/usr --sysconfdir=/etc
make
make install

# comedi_calibrate:
cd /usr/local/src/comedi_calibrate
autoreconf -v -i
./configure --prefix=/usr --sysconfdir=/etc
make
make install

# setup udev permissions:
addgroup --system iocard
echo 'KERNEL=="comedi*", MODE="0660", GROUP="iocard"' > /etc/udev/rules.d/95-comedi.rules
\endcode
For details see the documentation for the comedi plugin set.


\subsection udev Setting up udev permissions for comedi device files

Once comedi is installed you also need to make sure that you (the
user) have appropriate permissions for accessing the comedi device
files. That is you need to be able to have read and write access to
the \c /dev/comedi* files. One elegant way to achieve this to create a
new group and tell udev to add the comedi device files to this group.

-# Login as root.
-# Create a new group "iocard":
\code
addgroup --system iocard
\endcode
-# Add udev rules to the /etc/udev/rules.d directory:
\code
echo 'KERNEL=="comedi*", MODE="0660", GROUP="iocard"' > /etc/udev/rules.d/95-comedi.rules
\endcode
-# Run
\code
udevadm trigger
\endcode
to apply your new udev rules
-# Add users to the "iocard" group:
\code
adduser \<username\> iocard
\endcode
After the next login, \c \<username\> is a member of the \c iocard group
and and has sufficient permissions to access the data acquisition boards through \c comedi.


\subsection installrelacs Setting up dynamic clamp for RELACS
You should install \c RTAI and the \c comedi drivers and library prior to
configuring RELACS, so that ./configure can detect the presence of the
\c comedi library. If you install \c RTAI and \c comedi later, simply run \c
./configure and \c make again to detect comedi and compile the
corresponding plugins for RELACS.

-# Login as a normal user
-# If you are not member of the \c iocard group (necessary for accessing the comedi devices), 
then
\code
sudo adduser $USER iocard
\endcode
\note You need to log out and log in again to actually be member of that group (maybe it is enough just to open a new shell, though).
-# \c cd into the RELACS top-level directory and run
\code
./configure
\endcode
This should detect comedi and RTAI (see message towards the end of the output of \c configure).
-# Then get rid of any previously compiled comedi and dynamic clamp modules:
\code
cd plugins/linuxdevices/comedi
make clean
make -j$(grep -c "^processor" /proc/cpuinfo)
cd -
cd plugins/linuxdevices/rtaicomedi
make clean
\endcode
-# Select features of the dynamic clamp module by commenting or uncommenting the defines
at the top of the file \c plugins/linuxdevices/rtaicomedi/module/moduledef.h
or by enabling them by the --enable-dynclamp options for ./configure
(see ./configure --help for a description of all available options).
-# Implement your dynamic clamp model in the file \c plugins/linuxdevices/rtaicomedi/module/model.c .
-# Compile the dynamic clamp plugins and the kernel module
\code
cd plugins/linuxdevices/rtaicomedi
make -j$(grep -c "^processor" /proc/cpuinfo)
\endcode
-# If you get an "-mpreferred-stack-boundary" error uncomment line 4 in \c plugins/linuxdevices/rtaicomedi/module/Makefile.in and run \c make again.
-# Load the dynamic-clamp kernel module (as root):
\code
sudo module/loadmodules.sh
\endcode
-# Run RELACS in \c plugins/linuxdevices/rtaicomedi :
\code
./relacslocal
\endcode
or with the patchclamp plugins:
\code
cd plugins/patchclamp
cp relacs.cfg.dynclamp relacs.cfg
./relacslocal
\endcode
-# Possible problems are:
  - Data acquisition does not start:
    - You might not have 
      sufficient permissions for reading and writing to the 
      \c /dev/comedi* devices. For a quick fix do
      \code
sudo chmod a+rw /dev/comedi*
      \endcode
      See \ref udev below for a better solution.
    - The %comedi and rtai modules are not properly loaded: check the output of \c module/loadmodules.sh and \c dmesg.
    - The %comedi device is not configured yet (should not be a problem with a recent comedi version).
    .
  - Performance is bad / RELACS regularly hangs for a few seconds / RELACS seems to be slowed down dramatically:
    - Improve your rtai kernel! Recompile with "some" device modules disabled.
    - You may also try to disable APM and ACPI by adding \c "apm=off" and \c acpi=off to the kernel parameter in the \c kernel line of the
      \c grub menu in \c /boot/grub/menu.lst .
    .
  .
-# When developing your dynamic clamp model in \c model.c or if you dare to modify \c dynclampmodule.c, then
\code
cd plugins/linuxdevices/rtaicomedi
# whenever you changed something, do:
make
sudo module/reloadmodule.sh
\endcode
Your \c model.c implementation can be tested without RTAI in the simulation mode of relacs, see \ref simulatedynclamp below.
-# If you want to load the dynamic-clamp kernel module automatically during 
the boot process, then call the \c loadmodules.sh script from the script
\c /etc/rc.local . Simply add a line like this
\code
/where/ever/the/script/is/located/loadmodules.sh
\endcode
to \c /etc/rc.local (as root).


\subsection kernelmessages Kernel messages
When fiddling around with kernel modules you might want to have a look 
at the kernel messages in \c /var/log/messages:
\code
tail -f /var/log/messages
\endcode
alternatively use
\code
less /var/log/messages
\endcode
and hit 'F'. Both commands will then show what was added 
to the messages immediately. Interrupt this by hitting \c ctrl-c.

In case you do not have a \c /var/log/messages file
(unfortunately the default in modern ubuntu based systems),
you have to enable it. As root open the file \c /etc/rsyslog.d/50-default.conf
in an editor. Remove the hash marks in front of the following lines and add '*.=err;':
\code
*.=info;*.=notice;*.=warn;*.=err;\\
        auth,authpriv.none;\\
        cron,daemon.none;\\
        mail,news.none          -/var/log/messages
\endcode
Then tell the system that you changed this file (still as root):
\code
restart rsyslog 
\endcode


\section configdynamicclamp Configure dynamic clamp in RELACS

Just make sure your \c relacs.cfg file has the following device sections:
\code
*Analog Input Devices
  Device1:
      plugin: [ DynClampAnalogInput, DynClampAISim ]
      device: /dev/comedi0
      ident : ai-1

*Analog Output Devices
  Device1:
      plugin: [ DynClampAnalogOutput, DynClampAOSim ]
      device: /dev/comedi0
      ident : ao-1
\endcode

\subsection inputtraces  Input traces 
As usual, input traces can be assigned to channels
of the analog input device. All the input traces the dynamic clamp
model requires (its \c inputNames) must be available.

Some additional input traces might be available. They can be accessed like
normal analog input traces, but the channel nummber needs to be set to 1000 or larger.
The following three types of additional inputs are supported:
- additional inputs as defined by the dynamic clamp model via its \c paramInputNames.
- timing measurements, if they are enabled in moduledef.h:
  - \c Interval : the full period of the dynamic clamp loop
  - \c AI-time : the time required by the analog input part
  - \c AI-acquisition-time : the time required by reading in a single analog input channel
  - \c AI-conversion-time : the time required to convert the read in value
  - \c AO-time : the time required by the analog output part
  - \c Model-time : the time required for calling computModel()
  - \c Wait-time : the time rt_task_wait_period() waits for the next period
  .
  all times are measured in seconds.
- for each analog output trace the dynamic clamp model is using (its \c outputNames), 
  - \c Stimulus-xxx contains the stimulus a RePro wrote to this channel,
  - \c Model-xxx contains the value the model computed, and
  - \c Total-xxx contains the total requested output for this channel, i.e. Stimulus-xxx plus Model-xxx.
  - \c Injected-xxx contains the total output for this channel as it is written to the analog output.
    This equals \c Total-xxx multiplied by a possible correction factor and is only available with ENABLE_SYNCSEC
  .
  \c xxx is the name of the analog output trace. If the Injected or Total output exceeds the limits of the 
  maximum range of the data acquisition board, they are clipped to the minimum or maximum possible values.

\subsection outputtraces Output traces 
As usual, output traces can be assigned to channels
of the analog output device. All the output traces the dynamic clamp
model requires (its \c outputNames) must be available.

Additional output traces as defined by the dynamic clamp model via its
\c paramOutputNames be accessed like normal analog output traces by
their name.


\section simulatedynclamp Dynamic clamp simulation 
You can run the dynamic clamp in the relacs simulation mode as well.
This is in particular handy when it comes to testing your \c model.c
implementation without RTAI.

The relacs::DynClampAISim and relacs::DynClampAOSim modules do the trick.

Whenever you change \c model.c you need to recompile the
\c DynClampAISim and \c DynClampAOSim modules by calling \c make in the 
\c plugins/linuxdevices/rtaicomedi directory.
\code
cd plugins/linuxdevices/rtaicomedi
make
\endcode

Then call \c relacs with the \c -3 option
\code
./relacslocal -3
\endcode
and enjoy the simulation.


\section rtailinks Links
- comedi: http://www.comedi.org
- rtai: http://www.rtai.org
- Kernel testing und fixing: http://wiki.linuxcnc.org/cgi-bin/wiki.pl?TroubleShooting
- Installation instructions and kernel configuration: http://wiki.linuxcnc.org/cgi-bin/emcinfo.pl?Debian_Lenny_Compile_RTAI
- Kernel configuration: http://wiki.linuxcnc.org/cgi-bin/wiki.pl?Ubuntu10.04Notes
- Install kernel header package: http://www.cyberciti.biz/faq/howto-install-kernel-headers-package/
- mpreferred-stack-boundary=3 issue: http://mail.rtai.org/pipermail/rtai/2013-December/026198.html
- HPET timer kernel option: http://mail.rtai.org/pipermail/rtai/2013-April/025511.html
- localmodconfig kernel make target: http://www.heise.de/open/artikel/Linux-Kernel-massgeschneidert-1402386.html
- Maybe this link is helpful to find good motherboards: http://wiki.linuxcnc.org/cgi-bin/wiki.pl?Latency-Test.
- Linux kernel crash dump: https://help.ubuntu.com/12.04/serverguide/kernel-crash-dump.html
- Crash debugger: http://docs.oracle.com/cd/E52668_01/E54669/html/ol7-s4-sysdumpa.html
*/
