#include <linux/module.h>
#include <linux/init.h>
#include <linux/kernel.h>
#include <linux/version.h>
#include <asm/uaccess.h>
#include <linux/mutex.h>
#include <linux/slab.h>
#include <linux/vmalloc.h>
#include <linux/fs.h>
#include <linux/cdev.h>

#include <rtai.h>
#include <rtai_fifos.h>
#include <rtai_sched.h>

#include <linux/comedilib.h>

#include "moduledef.h"

#ifdef ENABLE_COMPUTATION
#ifndef ENABLE_LOOKUPTABLES
#include <rtai_math.h>
#endif
#endif


MODULE_LICENSE( "GPL" );
MODULE_DESCRIPTION( "Dynamic clamp for RELACS" );
MODULE_AUTHOR( "Jan Benda <jan.benda@uni-tuebingen.de>" );


///////////////////////////////////////////////////////////////////////////////
// *** TYPE DEFINITIONS ***
///////////////////////////////////////////////////////////////////////////////

// subdevice acquisition errors:
#define E_COMEDI    -1
#define E_NODATA    -2
#define E_UNDERRUN  -3
#define E_OVERFLOW  -4


// DAQ-DEVICES:

struct subdeviceT {
  int subdev;
  int userSubdevIndex;
  enum subdevTypes type;
  
  unsigned int fifo;

  unsigned int sampleSize;
  
  unsigned int chanN;
  struct chanT *chanlist;

  unsigned int frequency;
  long delay;
  long duration;           // => relative to index of dynclamp-Task
  int continuous;
  int startsource;

  int used;
  int prepared;
  int running;
  int pending;
  int error;               // E_COMEDI, E_NODATA, ...
};

struct chanT {
  int subdev;
  unsigned int chan;
  int isParamChan;
  int modelIndex;
  int isUsed;
  int aref;
  int rangeIndex;
  comedi_insn insn;
  lsampl_t lsample;
  struct converterT converter;
  float scale;
  unsigned int fifo;
  float voltage;
  float prevvoltage;
  int trigger;
  float alevel;
};


struct triggerT {
  int enabled;
  char devname[DEV_NAME_MAXLEN+1];
  int subdev;
  unsigned int chan;
  float alevel;
};


// RTAI TASK:

struct dynClampTaskT {
  RT_TASK rtTask;
  unsigned int periodLengthNs;
  unsigned int reqFreq;
  unsigned int setFreq;
  unsigned long duration;
  int continuous;
  int running;
  unsigned long loopCnt;
  long aoIndex;
  RTIME currenttime;
  RTIME sumperiod;
  RTIME sumsqperiod;
  RTIME minperiod;
  RTIME maxperiod;
};



///////////////////////////////////////////////////////////////////////////////
// *** GLOBAL VARIABLES ***
///////////////////////////////////////////////////////////////////////////////

struct cdev *rtcdev;
struct mutex mutex;

// DAQ-DEVICES:

comedi_t *device;
char devname[DEV_NAME_MAXLEN+1];

struct subdeviceT subdev[MAXSUBDEV];
int subdevN = 0;
struct subdeviceT *aisubdev = 0;
struct subdeviceT *aosubdev = 0;

int reqTraceSubdevID = -1;
int reqCloseSubdevID = -1;

struct triggerT trigger;

#ifdef ENABLE_COMPUTATION
int traceIndex = 0;
int chanIndex = 0;

#ifdef ENABLE_LOOKUPTABLES
int lookupinx = 0;
int lookupn[MAXLOOKUPTABLES];
float* lookupx[MAXLOOKUPTABLES];
float* lookupy[MAXLOOKUPTABLES];
#endif
#endif

// RTAI TASK:

struct dynClampTaskT dynClampTask;

// TTL pulse generation:
#ifdef ENABLE_TTLPULSE
comedi_insn *ttlStartWriteInsn[MAXTTLPULSES] = { 0, 0, 0, 0, 0 };
comedi_insn *ttlEndWriteInsn[MAXTTLPULSES] = { 0, 0, 0, 0, 0 };
comedi_insn *ttlStartReadInsn[MAXTTLPULSES] = { 0, 0, 0, 0, 0 };
comedi_insn *ttlEndReadInsn[MAXTTLPULSES] = { 0, 0, 0, 0, 0 };
comedi_insn *ttlStartAOInsn[MAXTTLPULSES] = { 0, 0, 0, 0, 0 };
comedi_insn *ttlEndAOInsn[MAXTTLPULSES] = { 0, 0, 0, 0, 0 };

comedi_insn **ttlInsns[MAXTTLPULSETYPES];

lsampl_t ttlLow = 0;
lsampl_t ttlHigh = 1;
#endif

#ifdef ENABLE_SYNCSEC
int syncSECPulse = 20000;  /*! Length of the inject pulse generated by the SEC in ns. */
comedi_insn syncSECInsnLow;
comedi_insn syncSECInsnHigh;
lsampl_t syncSECLow = 0;
lsampl_t syncSECHigh = 1;
#endif


// for debug:

char *iocNames[RTMODULE_IOC_MAXNR] = {
  "dummy",
  "IOC_GET_SUBDEV_ID", "IOC_OPEN_SUBDEV", "IOC_CHANLIST",
  "IOC_SYNC_CMD", "IOC_START_SUBDEV", "IOC_CHK_RUNNING", "IOC_REQ_READ",
  "IOC_REQ_WRITE", "IOC_REQ_CLOSE", "IOC_STOP_SUBDEV", "IOC_RELEASE_SUBDEV",
  "IOC_DIO_CMD", "IOC_SET_TRIGGER", "IOC_UNSET_TRIGGER", "IOC_GET_TRACE_INFO",
  "IOC_SET_TRACE_CHANNEL", "IOC_GETRATE", "IOC_GETLOOPCNT", "IOC_GETLOOPAVG",
  "IOC_GETLOOPSQAVG", "IOC_GETLOOPMIN", "IOC_GETLOOPMAX", "IOC_GETAOINDEX",
  "IOC_SET_LOOKUP_K", "IOC_SET_LOOKUP_N", "IOC_SET_LOOKUP_X", "IOC_SET_LOOKUP_Y"
};


///////////////////////////////////////////////////////////////////////////////
// *** PROTOTYPES ***
///////////////////////////////////////////////////////////////////////////////

int init_rt_task( void );
void cleanup_rt_task( void );
int rtmodule_open( struct inode *devFile, struct file *fModule );
int rtmodule_close( struct inode *devFile, struct file *fModule );
#ifdef HAVE_UNLOCKED_IOCTL
long rtmodule_unlocked_ioctl( struct file *fModule, unsigned int cmd,
			      unsigned long arg );
#else
int rtmodule_ioctl( struct inode *devFile, struct file *fModule, 
		    unsigned int cmd, unsigned long arg );
#endif
static struct file_operations fops = {                     
  .owner = THIS_MODULE,
#ifdef HAVE_UNLOCKED_IOCTL
  .unlocked_ioctl = rtmodule_unlocked_ioctl,
#else
  .ioctl = rtmodule_ioctl,
#endif
  .open = rtmodule_open, 
  .release = rtmodule_close,
};



///////////////////////////////////////////////////////////////////////////////
// *** MODEL INCLUDE ***
///////////////////////////////////////////////////////////////////////////////
#ifdef ENABLE_COMPUTATION
#include "model.c"
#endif

///////////////////////////////////////////////////////////////////////////////
// *** HELPER FUNCTIONS ***
///////////////////////////////////////////////////////////////////////////////

static inline void sample_to_value( struct chanT *pChan )
{
  double term = 1.0;
  double sample = pChan->lsample - pChan->converter.expansion_origin;
  unsigned i;

  pChan->voltage = 0.0;
  for ( i=0; i <= pChan->converter.order; ++i ) {
    pChan->voltage += pChan->converter.coefficients[i] * term;
    term *= sample;
  }
  pChan->voltage *= pChan->scale;
}


static inline void value_to_sample( struct chanT *pChan, float value )
{
  double sample = 0.0;
  double term = 1.0;
  unsigned i;
  value *= pChan->scale;
  value -= pChan->converter.expansion_origin;
  for ( i=0; i <= pChan->converter.order; ++i ) {
    sample += pChan->converter.coefficients[i] * term;
    term *= value;
  }
  pChan->lsample = (lsampl_t)sample;
}


void init_globals( void )
{
#ifdef ENABLE_COMPUTATION
#ifdef ENABLE_LOOKUPTABLES
  int k;
#endif
#endif

  subdevN = 0;
  aisubdev = 0;
  aosubdev = 0;
  reqCloseSubdevID = -1;
  reqTraceSubdevID = -1;
#ifdef ENABLE_COMPUTATION
  traceIndex = 0;
  chanIndex = 0;
#ifdef ENABLE_LOOKUPTABLES
  lookupinx = 0;
  for ( k=0; k<MAXLOOKUPTABLES; k++ ) {
    lookupn[k] = 0;
    if ( lookupx[lookupinx] != NULL ) {
      kfree( lookupx[lookupinx] );
      lookupx[lookupinx] = NULL;
    }
    if ( lookupy[lookupinx] != NULL ) {
      kfree( lookupy[lookupinx] );
      lookupy[lookupinx] = NULL;
    }
  }
#endif
#endif
  device = 0;
  memset( subdev, 0, sizeof(subdev) );
  memset( &dynClampTask, 0, sizeof(struct dynClampTaskT ) );

#ifdef ENABLE_TTLPULSE
  ttlInsns[0] = ttlStartWriteInsn;
  ttlInsns[1] = ttlEndWriteInsn;
  ttlInsns[2] = ttlStartReadInsn;
  ttlInsns[3] = ttlEndReadInsn;
  ttlInsns[4] = ttlStartAOInsn;
  ttlInsns[5] = ttlEndAOInsn;
#endif
#ifdef ENABLE_SYNCSEC
  memset( &syncSECInsnLow, 0, sizeof(comedi_insn) );
  syncSECInsnLow.insn = INSN_WRITE;
  syncSECInsnLow.subdev = -1;
  syncSECInsnLow.n = 1;
  syncSECInsnLow.data = &syncSECLow;
  memset( &syncSECInsnHigh, 0, sizeof(comedi_insn) );
  syncSECInsnHigh.insn = INSN_WRITE;
  syncSECInsnHigh.subdev = -1;
  syncSECInsnHigh.n = 1;
  syncSECInsnHigh.data = &syncSECHigh;
#endif
}


///////////////////////////////////////////////////////////////////////////////
// *** DAQ FUNCTIONS ***
///////////////////////////////////////////////////////////////////////////////

int getSubdevID( void )
{
  int i = 0;
  // find free slot in subdev[]:
  for ( i = 0; i < subdevN && subdev[i].used; i++ );
  if ( i == subdevN ) {
    if ( subdevN >= MAXSUBDEV ) {
      ERROR_MSG( "getSubdevID ERROR: number of requested subdevices exceeds MAXSUBDEV!\n" );
      return -1;
    }
    subdevN++;
  }
  memset( &(subdev[i]), 0, sizeof(struct subdeviceT) );
  subdev[i].used = 1;
  subdev[i].subdev = -1;
  subdev[i].sampleSize = sizeof(float);
  return i;
}


int openComediDevice( struct deviceIOCT *deviceIOC )
{
  int iS, retVal;
  int justOpened = 0;

  // scan device list for either the opened device or a free slot:
  if ( device ) {
    if ( strcmp( deviceIOC->devicename, devname ) == 0 ) {
      DEBUG_MSG( "comediOpenDevice: device %s is opened already ...", 
		 devname );
    }
    else {
      DEBUG_MSG( "comediOpenDevice: there is a different device opened %s already, requested to open %s.", 
		 devname, deviceIOC->devicename );
      return -1;
    }
  }

  if ( ! device ) {
    // open comedi device:
    device = comedi_open( deviceIOC->devicename );
    if ( ! device ) {
      ERROR_MSG( "comediOpenDevice: device %s could not be opened!\n",
		 deviceIOC->devicename );
      comedi_perror( "dynclampmodule: comedi_open" );    
      return -1;
    }
    justOpened = 1;
    DEBUG_MSG( "openComediDevice: opened device %s\n",  deviceIOC->devicename );
  }

  // lock requested subdevice:
  if ( deviceIOC->subdev >= comedi_get_n_subdevices( device ) ||
       comedi_lock( device, deviceIOC->subdev ) != 0 ) {
    ERROR_MSG( "comediOpenDevice: Subdevice %i on device %s could not be locked!\n",
	       deviceIOC->subdev, deviceIOC->devicename );
    // locking failed => close just opened comedi device:
    if ( justOpened ) {
      if ( comedi_close( device ) < 0 )
      	WARN_MSG( "comediOpenDevice WARNING: closing of device %s failed!\n",
		  deviceIOC->devicename );
      else
	DEBUG_MSG( "comediOpenDevice: Closing of device %s was successful!\n",
		   deviceIOC->devicename );
      device = 0;
    }    
    return -1;
  }

  // initialize device name:
  strncpy( devname, deviceIOC->devicename, DEV_NAME_MAXLEN );

  DEBUG_MSG( "openComediDevice: locked subdevice %i on device %s\n", 
             deviceIOC->subdev, devname );
  
  // initialize subdevice structure:
  iS = deviceIOC->subdevID;
  subdev[iS].subdev = deviceIOC->subdev;
  subdev[iS].userSubdevIndex = -1;
  subdev[iS].type = deviceIOC->subdevType;
  subdev[iS].delay = -1; 
  subdev[iS].duration = -1;
  subdev[iS].startsource = 0;
  subdev[iS].chanN = 0;
  subdev[iS].chanlist = 0;
  subdev[iS].running = 0;

  if ( subdev[iS].type == SUBDEV_IN || subdev[iS].type == SUBDEV_OUT ) {

    // create FIFO for subdevice:
    subdev[iS].fifo = iS;
    retVal = rtf_create( subdev[iS].fifo, FIFO_SIZE );
    if ( retVal ) {
      ERROR_MSG( "openComediDevice ERROR: Creating FIFO with %d bytes buffer failed for subdevice %i, device %s\n",
		 FIFO_SIZE, iS, devname );
      return -1;
    }
    else
      DEBUG_MSG( "openComediDevice: Created FIFO with %d bytes buffer size for subdevice %i, device %s\n",
		 FIFO_SIZE, iS, devname );

    // pass FIFO properties to user:
    deviceIOC->fifoIndex = subdev[iS].fifo;
    deviceIOC->fifoSize = FIFO_SIZE;

    // set special subdevice:
    if ( subdev[iS].type == SUBDEV_IN )
      aisubdev = &subdev[iS];
    else if ( subdev[iS].type == SUBDEV_OUT )
      aosubdev = &subdev[iS];
  }
  else {
    deviceIOC->fifoIndex = 0;
    deviceIOC->fifoSize = 0;
  }

  return 0;
}


int loadChanlist( struct chanlistIOCT *chanlistIOC )
{
  int iS = chanlistIOC->subdevID;
  int iC, isC;
  int trig = 0;
#ifdef ENABLE_COMPUTATION
  int i;
#endif

  if ( subdev[iS].subdev < 0 || !subdev[iS].used ) {
    ERROR_MSG( "loadChanlist ERROR: First open an appropriate device and subdevice. Chanlist not loaded!\n" );
    return -1;
  }

  if ( chanlistIOC->chanlistN > MAXCHANLIST ) {
    ERROR_MSG( "loadChanlist ERROR: Invalid chanlist length for Subdevice %i on device %s. Chanlist not loaded!\n",
	       iS, devname );
    return -1;
  }

  // check for trigger:
  if ( trigger.enabled &&
       strcmp( devname, trigger.devname ) == 0 ) {
    if ( trigger.subdev >= 0 ) {
      if ( subdev[iS].subdev == trigger.subdev )
	trig = 1;
    }
    else {
      if ( subdev[iS].type == SUBDEV_IN )
	trig = 1;
    }
    DEBUG_MSG( "checked for trigger on subdevice %d: %d\n", subdev[iS].subdev, trig );
  }

  if ( subdev[iS].chanlist ) {
    // subdev chanlist already exist
    for ( iC = 0; iC < chanlistIOC->chanlistN; iC++ ) {
      for ( isC = 0; isC < subdev[iS].chanN; isC++ ) {
        if ( CR_CHAN(chanlistIOC->chanlist[iC]) == 
	     subdev[iS].chanlist[isC].chan + PARAM_CHAN_OFFSET*subdev[iS].chanlist[isC].isParamChan ) {
	  subdev[iS].chanlist[isC].isUsed = 1;
	  if ( trig && subdev[iS].chanlist[iC].chan == trigger.chan ) {
	    DEBUG_MSG( "set trigger for channel %d id %d on subdevice %d with level %d\n", subdev[iS].chanlist[iC].chan, iC, subdev[iS].subdev, (int)(100.0*trigger.alevel) );
	    subdev[iS].chanlist[iC].trigger = 1;
	    subdev[iS].chanlist[iC].alevel = trigger.alevel;
	  }
	  else {
	    subdev[iS].chanlist[iC].trigger = 0;
	    subdev[iS].chanlist[iC].alevel = 0.0;
	  }
	  if ( ! subdev[iS].chanlist[isC].isParamChan ) {
	    subdev[iS].chanlist[isC].aref = CR_AREF( chanlistIOC->chanlist[iC] );
	    subdev[iS].chanlist[isC].rangeIndex = CR_RANGE( chanlistIOC->chanlist[iC] );
	    subdev[iS].chanlist[isC].insn.chanspec = chanlistIOC->chanlist[iC];
	    memcpy( &subdev[iS].chanlist[iC].converter, &chanlistIOC->conversionlist[iC], sizeof(struct converterT) );
	    subdev[iS].chanlist[isC].scale = chanlistIOC->scalelist[iC];
	  }
	  break;
        }
      }
    }
  }
  else {
    
    // create and initialize chanlist for subdevice:
    subdev[iS].chanlist = vmalloc( chanlistIOC->chanlistN
				   *sizeof(struct chanT) );
    if ( !subdev[iS].chanlist ) {
      ERROR_MSG( "loadChanlist ERROR: Memory allocation for Subdevice %i on device %s. Chanlist not loaded!\n",
		 iS, devname );
      return -1;
    }
    subdev[iS].chanN = chanlistIOC->chanlistN;
    subdev[iS].userSubdevIndex = chanlistIOC->userDeviceIndex;
    
    for ( iC = 0; iC < subdev[iS].chanN; iC++ ) {
      subdev[iS].chanlist[iC].subdev = subdev[iS].subdev;
      subdev[iS].chanlist[iC].chan = CR_CHAN( chanlistIOC->chanlist[iC] );
      subdev[iS].chanlist[iC].lsample = 0;
      memset( &subdev[iS].chanlist[iC].insn, 0, sizeof(comedi_insn) );
      subdev[iS].chanlist[iC].isParamChan = (subdev[iS].chanlist[iC].chan >= PARAM_CHAN_OFFSET);
      subdev[iS].chanlist[iC].modelIndex = -1;
      subdev[iS].chanlist[iC].isUsed = 1; 
      subdev[iS].chanlist[iC].voltage = 0.0; 
      subdev[iS].chanlist[iC].prevvoltage = 0.0;
      subdev[iS].chanlist[iC].fifo = subdev[iS].fifo;
      if ( trig && subdev[iS].chanlist[iC].chan == trigger.chan ) {
	DEBUG_MSG( "added trigger to channel %d id %d on subdevice %d with level %d\n", subdev[iS].chanlist[iC].chan, iC, subdev[iS].subdev, (int)(100.0*trigger.alevel) );
	subdev[iS].chanlist[iC].trigger = 1;
	subdev[iS].chanlist[iC].alevel = trigger.alevel;
      }
      else {
	subdev[iS].chanlist[iC].trigger = 0;
	subdev[iS].chanlist[iC].alevel = 0.0;
      }
#ifdef ENABLE_COMPUTATION
      if ( subdev[iS].chanlist[iC].isParamChan ) {
	subdev[iS].chanlist[iC].chan -= PARAM_CHAN_OFFSET;
	subdev[iS].chanlist[iC].aref = 0;
	subdev[iS].chanlist[iC].rangeIndex = 0;
	memset( &subdev[iS].chanlist[iC].converter, 0, sizeof( struct converterT ) );
	subdev[iS].chanlist[iC].scale = 1.0;
      }
      else {
#endif
	if ( subdev[iS].type == SUBDEV_IN ) {
	  subdev[iS].chanlist[iC].insn.insn = INSN_READ;
#ifdef ENABLE_COMPUTATION
	  for ( i = 0; i < INPUT_N; i++ ) {
	    if ( inputDevices[i] == subdev[iS].userSubdevIndex && 
		 inputChannels[i] == subdev[iS].chanlist[iC].chan )
	      subdev[iS].chanlist[iC].modelIndex = i;
	  }
#endif
	}
	else {
	  subdev[iS].chanlist[iC].insn.insn = INSN_WRITE;
#ifdef ENABLE_COMPUTATION
	  for ( i = 0; i < OUTPUT_N; i++ ) {
	    if ( outputDevices[i] == subdev[iS].userSubdevIndex && 
		 outputChannels[i] == subdev[iS].chanlist[iC].chan )
	      subdev[iS].chanlist[iC].modelIndex = i;
	  }
#endif
	}
	subdev[iS].chanlist[iC].aref = CR_AREF( chanlistIOC->chanlist[iC] );
	subdev[iS].chanlist[iC].rangeIndex = CR_RANGE( chanlistIOC->chanlist[iC] );
	subdev[iS].chanlist[iC].insn.n = 1;
	subdev[iS].chanlist[iC].insn.data = &subdev[iS].chanlist[iC].lsample;
	subdev[iS].chanlist[iC].insn.subdev = subdev[iS].subdev;
	subdev[iS].chanlist[iC].insn.chanspec = chanlistIOC->chanlist[iC];
	memcpy( &subdev[iS].chanlist[iC].converter, &chanlistIOC->conversionlist[iC], sizeof(struct converterT) );
	subdev[iS].chanlist[iC].scale = chanlistIOC->scalelist[iC];
#ifdef ENABLE_COMPUTATION
      }
#endif
    }
  }    
  return 0;
}


int loadSyncCmd( struct syncCmdIOCT *syncCmdIOC )
{
  int iS = syncCmdIOC->subdevID;

  if ( subdev[iS].subdev < 0 || !subdev[iS].used ) {
    ERROR_MSG( "loadSyncCmd ERROR: First open an appropriate device and subdevice. Sync-command not loaded!\n" );
    return -EFAULT;
  }
  if ( !subdev[iS].chanlist ) {
    ERROR_MSG( "loadSyncCmd ERROR: First load Chanlist for Subdevice %i on device %s. Sync-command not loaded!\n",
	       iS, devname );
    return -EFAULT;
  }
  if ( syncCmdIOC->frequency > MAX_FREQUENCY ) {
    ERROR_MSG( "LOAdSyncCmd ERROR: Requested frequency is above MAX_FREQUENCY (%d Hz). Sync-command not loaded!\n",
	       MAX_FREQUENCY );
    return -EINVAL;
  }

  // initialize sampling parameters for subdevice:
  subdev[iS].frequency = syncCmdIOC->frequency > 0 ? syncCmdIOC->frequency : dynClampTask.setFreq;
  subdev[iS].delay = syncCmdIOC->delay;
  subdev[iS].duration = syncCmdIOC->duration;
  subdev[iS].continuous = syncCmdIOC->continuous;
  subdev[iS].startsource = syncCmdIOC->startsource;
  subdev[iS].pending = 0;

  DEBUG_MSG( "loadSyncCmd: loaded %ld samples with startsource %d for subdevice %d\n", subdev[iS].duration, subdev[iS].startsource, iS );

  // test requested sampling-rate and set frequency for dynamic clamp task:
  if ( !dynClampTask.reqFreq ) {
    dynClampTask.reqFreq = subdev[iS].frequency;
  }
  else {
    if ( dynClampTask.setFreq != subdev[iS].frequency ) {
      ERROR_MSG( "loadSyncCmd ERROR: Requested frequency %u Hz of subdevice %i on device %s is inconsistent to frequency %u Hz of other subdevice. Sync-command not loaded!\n",
		 subdev[iS].frequency, iS, devname, dynClampTask.setFreq );
      return -EINVAL;
    }
  }

  subdev[iS].prepared = 1;
  return 0;
}


int startSubdevice( int iS )
{ 
  int retVal = 0;

  if ( !subdev[iS].prepared || subdev[iS].running ) {
    ERROR_MSG( "startSubdevice ERROR:  Subdevice ID %i on device %s either not prepared or already running.\n",
	       iS, devname );
    return -EBUSY;
  }

  subdev[iS].pending = 1;
  if ( !dynClampTask.running ) {
    dynClampTask.aoIndex = 0;
    dynClampTask.reqFreq = subdev[iS].frequency;

    // start dynamic clamp task: 
    retVal = init_rt_task();
    if ( retVal < 0 ) {
      ERROR_MSG( "startSubdevice: failed to start dynamic clamp loop for subdevice %d type %s!\n",
		 iS, subdev[iS].type == SUBDEV_IN ? "AI" : "AO" );
      subdev[iS].running = 0;
      return -ENOMEM;
    }
    SDEBUG_MSG( "startSubdevice: successfully started rt_task!\n" );
  }

  subdev[iS].running = 1;

  SDEBUG_MSG( "startSubdevice: successfully started subdevice %d type %s!\n",
	     iS, subdev[iS].type == SUBDEV_IN ? "AI" : "AO" );

  return 0;
}


int stopSubdevice( struct subdeviceT *subd, int kill )
{ 
  int i;
#ifdef ENABLE_STATISTICS
  long long mean;
  long long sqmean;
  long long var;
#endif

  if ( !subd->running )
    return 0;
  subd->running = 0;
  for ( i = 0; i < subd->chanN; i++ )
    subd->chanlist[i].isUsed = 0;
  SDEBUG_MSG( "stopSubdevice with kill=%d\n", kill );

  if ( !kill )
    return 0;

  // if all subdevices stopped => halt dynclamp task:
  for ( i = 0; i < subdevN; i++ )
    if ( subdev[i].running )
      return 0;
  SDEBUG_MSG( "stopSubdevice halts dynclamp task\n" );
#ifdef ENABLE_STATISTICS
  /*" XXX Unknown symbol __divdi3: use rtai_ulldiv() from include/asm-i386/rtai_hal.h !!! */
  mean = dynClampTask.sumperiod/dynClampTask.loopCnt;
  sqmean = dynClampTask.sumsqperiod/dynClampTask.loopCnt;
  var = sqmean - mean*mean;
  SDEBUG_MSG( "dynclampmodule: average period %Lu ns, var=%Lu, min=%Lu, max=%Lu, count=%lu\n", mean, var, dynClampTask.minperiod, dynClampTask.maxperiod, dynClampTask.loopCnt );
#endif
  cleanup_rt_task();
  return 0;
}


void releaseSubdevice( int iS )
{
#ifdef ENABLE_TTLPULSE
  int pT;
  int iT;
  int k;
  comedi_insn *insn;
  int retVal;
#endif

  if ( iS >= subdevN || !subdev[iS].used || subdev[iS].subdev < 0 ) {
    ERROR_MSG( "releaseSubdevice ERROR: Subdevice with ID %d not in use!\n", iS );
    return;
  }

  // stop subdevice:
  if ( subdev[iS].running ) {
    SDEBUG_MSG( "releaseSubdevice stops and potentially kills subdevice %d\n", iS );
    stopSubdevice( &subdev[iS], /*kill=*/1 );
  }
  
  // unlock subdevice:
  if ( device && comedi_unlock( device, subdev[iS].subdev ) < 0 )
    WARN_MSG( "releaseSubdevice WARNING: unlocking of subdevice %s failed!\n",
	      devname );
  else
    DEBUG_MSG( "releaseSubdevice: Unlocking of subdevice %s was successful!\n",
	       devname );

  if ( subdev[iS].chanlist ) {
    vfree( subdev[iS].chanlist );
    subdev[iS].chanlist = 0;
  }

  if ( subdev[iS].type == SUBDEV_IN || subdev[iS].type == SUBDEV_OUT ) {
    // delete FIFO
    rtf_destroy( subdev[iS].fifo );
    if ( subdev[iS].type == SUBDEV_IN )
      aisubdev = 0;
    else if ( subdev[iS].type == SUBDEV_OUT )
      aosubdev = 0;
  }
#ifdef ENABLE_TTLPULSE
  else if ( subdev[iS].type == SUBDEV_DIO ) {
    // remove ttl pulses:
    for ( pT = 0; pT < MAXTTLPULSETYPES; pT++ ) {
      for ( iT = 0; iT < MAXTTLPULSES; ) {
	if ( ttlInsns[pT][iT]->subdev == subdev[iS].subdev ) {
	  /* remove from list: */
	  insn = ttlInsns[pT][iT];
	  for ( k = iT+1; k < MAXTTLPULSES; k++ )
	    ttlInsns[pT][k-1] = ttlInsns[pT][k];
	  ttlInsns[pT][MAXTTLPULSES-1] = 0;
	  /* set low: */
	  insn->data = &ttlLow;
	  retVal = comedi_do_insn( device, insn );
	  if ( retVal < 1 ) {
	    if ( retVal < 0 )
	      comedi_perror( "dynclampmodule: releaseSubdevice() -> clearing ttl pulse: comedi_do_insn" );
	    ERROR_MSG( "releaseSubdevice() -> ERROR! failed to set TTL pulse %d low\n", iT );
	  }
	  vfree( insn );
	}
	else
	  iT++;
      }
    }
  }
#endif

  // reset subdevice structure:
  memset( &(subdev[iS]), 0, sizeof(struct subdeviceT) );
  SDEBUG_MSG( "releaseSubdevice released subdevice %d\n", iS );
  if ( iS == subdevN - 1 )
    subdevN--;
 
  // check if comedi device for subdevice is still in use:
  if ( subdevN > 0 )
    // device is still used by another subdevice => leave here:
    return;

  // close comedi device:
  DEBUG_MSG( "releaseSubdevice: released device for last subdev-ID %d\n", iS );
  if ( device && comedi_close( device ) < 0 )
    WARN_MSG( "releaseSubdevice WARNING: closing of device %s failed!\n",
	      devname );
  else
    DEBUG_MSG( "releaseSubdevice: Closing of device %s was successful!\n",
	       devname );

  // reset device structure:
  device = 0;
}


int setDigitalIO( struct dioIOCT *dioIOC )
{
  int iS = dioIOC->subdevID;
  int subdevice = subdev[iS].subdev;
  unsigned int bit = 0;
  int channel = 0;
  int direction = 0;
#ifdef ENABLE_TTLPULSE
  int pT = dioIOC->pulseType;
  int iT = 0;
  int k = 0;
  int found = 0;
#endif

  if ( dioIOC->op == DIO_CONFIGURE ) {
    if ( dioIOC->bitfield ) {
      bit = 1;
      for ( channel=0; channel<32; channel++ ) {
	if ( ( dioIOC->lines & bit ) > 0 ) {
	  direction = COMEDI_INPUT;
	  if ( ( dioIOC->output & bit ) > 0 )
	    direction = COMEDI_OUTPUT;
	  if ( comedi_dio_config( device, subdevice, channel, direction ) < 0 ) {
	    comedi_perror( "setDigitalIO() -> DIO_CONFIGURE" );
	    ERROR_MSG( "setDigitalIO: comedi_dio_config bitfield on device %s, subdevice %d, channel %d, direction %d failed!\n",
		       devname, subdevice, channel, direction );
	    return -EFAULT;
	  }
	}
	bit *= 2;
      }
    }
    else {
      direction = dioIOC->output ? COMEDI_OUTPUT : COMEDI_INPUT;
      if ( comedi_dio_config( device, subdevice, dioIOC->lines, direction ) < 0 ) {
	comedi_perror( "setDigitalIO() -> DIO_CONFIGURE" );
	ERROR_MSG( "setDigitalIO: comedi_dio_config single channel on device %s, subdevice %d, channel %d, direction %d failed!\n",
		   devname, subdevice, dioIOC->lines, direction );
	return -EFAULT;
      }
    }
  }
  else if ( dioIOC->op == DIO_READ ) {
    if ( dioIOC->bitfield ) {
      bit = 0;
      if ( comedi_dio_bitfield( device, subdevice, dioIOC->lines, &bit ) < 0 ) {
	comedi_perror( "setDigitalIO() -> DIO_READ" );
	ERROR_MSG( "setDigitalIO: comedi_dio_read on device %s subdevice %d failed!\n",
		  devname, subdevice );
	return -EFAULT;
      }
      dioIOC->output = bit & dioIOC->lines;
    }
    else {
      bit = 0;
      if ( comedi_dio_read( device, subdevice, dioIOC->lines, &bit ) != 1 ) {
	comedi_perror( "setDigitalIO() -> DIO_READ" );
	ERROR_MSG( "setDigitalIO: comedi_dio_read on device %s subdevice %d failed!\n",
		  devname, subdevice );
	return -EFAULT;
      }
      dioIOC->output = bit;
    }
  }
  else if ( dioIOC->op == DIO_WRITE ) {
    if ( dioIOC->bitfield ) {
      bit = dioIOC->output;
      if ( comedi_dio_bitfield( device, subdevice, dioIOC->lines, &bit ) < 0 ) {
	comedi_perror( "setDigitalIO() -> DIO_WRITE" );
	ERROR_MSG( "setDigitalIO: comedi_dio_write on device %s subdevice %d failed!\n",
		  devname, subdevice );
	return -EFAULT;
      }
    }
    else {
      if ( comedi_dio_write( device, subdevice, dioIOC->lines, dioIOC->output ) != 1 ) {
	comedi_perror( "setDigitalIO() -> DIO_WRITE" );
	ERROR_MSG( "setDigitalIO: comedi_dio_write on device %s subdevice %d failed!\n",
		  devname, subdevice );
	return -EFAULT;
      }
    }
  }
#ifdef ENABLE_TTLPULSE
  else if ( dioIOC->op == DIO_ADD_TTLPULSE ) {
    if ( pT < TTL_START_WRITE || pT >= MAXTTLPULSETYPES )
      return -EINVAL;
    for ( iT = 0; iT < MAXTTLPULSES && ttlInsns[pT][iT] != 0; iT++ );
    if ( iT >= MAXTTLPULSES )
      return -ENOMEM;
    if ( comedi_dio_write( device, subdevice, dioIOC->lines, dioIOC->output ) != 1 ) {
      comedi_perror( "setDigitalIO() -> DIO_ADD_TTLPULSE" );
      ERROR_MSG( "setDigitalIO: comedi_dio_write on device %s subdevice %d failed!\n",
		 devname, subdevice );
      return -EFAULT;
    }
    ttlInsns[pT][iT] = vmalloc( sizeof(comedi_insn) );
    memset( ttlInsns[pT][iT], 0, sizeof(comedi_insn) );
    ttlInsns[pT][iT]->insn = INSN_WRITE;
    ttlInsns[pT][iT]->n = 1;
    ttlInsns[pT][iT]->data = ( dioIOC->output ? &ttlHigh : &ttlLow );
    ttlInsns[pT][iT]->subdev = subdevice;
    ttlInsns[pT][iT]->chanspec = CR_PACK( dioIOC->lines, 0, 0 );
    DEBUG_MSG( "add pulse pT=%d  iT=%d  output=%d subdev=%d lines=%d\n", pT, iT, ttlInsns[pT][iT]->data[0], ttlInsns[pT][iT]->subdev, ttlInsns[pT][iT]->chanspec );
  }
  else if ( dioIOC->op == DIO_CLEAR_TTLPULSE ) {
    found = 0;
    for ( pT = 0; pT < MAXTTLPULSETYPES; pT++ ) {
      for ( iT = 0; iT < MAXTTLPULSES && ttlInsns[pT][iT] != 0; ) {
	if ( ttlInsns[pT][iT]->subdev == subdevice &&
	     ttlInsns[pT][iT]->chanspec == CR_PACK( dioIOC->lines, 0, 0 ) ) {
	  found = 1;
	  vfree( ttlInsns[pT][iT] );
	  ttlInsns[pT][iT] = 0;
	  for ( k = iT+1; k < MAXTTLPULSES; k++ )
	    ttlInsns[pT][k-1] = ttlInsns[pT][k];
	  ttlInsns[pT][MAXTTLPULSES-1] = 0;
	}
	else
	  iT++;
      }
    }
    if ( found ) {
      if ( comedi_dio_write( device, subdevice, dioIOC->lines, dioIOC->output ) != 1 ) {
	comedi_perror( "setDigitalIO() -> DIO_CLEAR_TTLPULSE" );
	ERROR_MSG( "setDigitalIO: comedi_dio_write on device %s subdevice %d failed!\n",
		   devname, subdevice );
	return -EFAULT;
      }
    }
  }
#endif
#ifdef ENABLE_SYNCSEC
  else if ( dioIOC->op == DIO_SET_SYNCPULSE ) {
    syncSECInsnLow.subdev = subdevice;
    syncSECInsnLow.chanspec = CR_PACK( dioIOC->lines, 0, 0 );
    syncSECInsnHigh.subdev = subdevice;
    syncSECInsnHigh.chanspec = CR_PACK( dioIOC->lines, 0, 0 );
    syncSECPulse = dioIOC->pulsewidth;
    if ( syncSECPulse <= 0 ) {
      ERROR_MSG( "setDigitalIO: syncSECPulse %d ns is not positive!\n", syncSECPulse );
      syncSECPulse = 20000;
      syncSECInsnLow.subdev = -1;
      syncSECInsnLow.chanspec = 0;
      syncSECInsnHigh.subdev = -1;
      syncSECInsnHigh.chanspec = 0;
      ERROR_MSG( "setDigitalIO: disabled syncSECPulse.\n" );
      return -EVALUE;
    }
    if ( comedi_do_insn( device, &syncSECInsnHigh ) != 1 ) {
      comedi_perror( "setDigitalIO() -> DIO_SET_SYNCPULSE" );
      ERROR_MSG( "setDigitalIO: comedi_dio_write on device %s subdevice %d failed!\n",
		 devname, subdevice );
      syncSECInsnLow.subdev = -1;
      syncSECInsnLow.chanspec = 0;
      syncSECInsnHigh.subdev = -1;
      syncSECInsnHigh.chanspec = 0;
      ERROR_MSG( "setDigitalIO: disabled syncSECPulse.\n" );
      return -EFAULT;
    }
  }
  else if ( dioIOC->op == DIO_CLEAR_SYNCPULSE ) {
    if ( syncSECInsnLow.subdev >= 0 ) {
      if ( comedi_do_insn( device, &syncSECInsnLow ) != 1 ) {
	comedi_perror( "setDigitalIO() -> DIO_SET_SYNCPULSE" );
	ERROR_MSG( "setDigitalIO: comedi_dio_write on device %s subdevice %d failed!\n",
		   devname, subdevice );
	return -EFAULT;
      }
    }
    syncSECInsnLow.subdev = -1;
    syncSECInsnLow.chanspec = 0;
    syncSECInsnHigh.subdev = -1;
    syncSECInsnHigh.chanspec = 0;
  }
#endif
  else
    return -EINVAL;
  return 0;
}


int setAnalogTrigger( struct triggerIOCT *triggerIOC )
{
#ifdef ENABLE_TRIGGER
  // disable trigger:
  trigger.enabled = 0;

  // setup trigger parameter:
  strcpy( trigger.devname, triggerIOC->devname );
  trigger.subdev = triggerIOC->subdev;
  trigger.chan = triggerIOC->channel;
  trigger.alevel = triggerIOC->alevel;

  DEBUG_MSG( "dynclampmodule: setup trigger for channel %d on device %s\n",
	     trigger.chan, trigger.devname );

  // enable trigger:
  trigger.enabled = 1;
  return 0;
#else
  return -EINVAL;
#endif
}


int unsetAnalogTrigger( struct triggerIOCT *triggerIOC )
{
#ifdef ENABLE_TRIGGER
  int iS, iC;

  // disable trigger:
  trigger.enabled = 0;
  for ( iS = 0; iS < subdevN; iS++ ) {
    for ( iC = 0; iC < subdev[iS].chanN; iC++ ) {
      subdev[iS].chanlist[iC].trigger = 0;
    }
  }

  return 0;
#else
  return -EINVAL;
#endif
}


///////////////////////////////////////////////////////////////////////////////
// *** REAL-TIME TASKS *** 
///////////////////////////////////////////////////////////////////////////////


/*! Dynamic clamp task */
void rtDynClamp( long dummy )
{
  int retVal;
  int iC;
#ifdef ENABLE_TTLPULSE
  int iT;
#endif
  int subdevRunning = 1;
  unsigned long readCnt = 0;
  struct chanT *pChan;
  float voltage;
#if defined(ENABLE_STATISTICS) || defined(ENABLE_SYNCSEC)
  RTIME newtime = 0;
  int difftime = 0;   // to avoid __divdi3 issues we use an int here
#endif
  int triggerevs[5] = { 1, 0, 0, 0, 0 };
  int prevtriggerevs[5] = { 0, 0, 0, 0, 0 };
#ifdef ENABLE_SYNCSEC
  float currentfac = 1.0;
#endif

  SDEBUG_MSG( "dynclampmodule: starting dynamic clamp loop at %u Hz\n", 
	      1000000000/dynClampTask.periodLengthNs );

  dynClampTask.loopCnt = 0;
  dynClampTask.aoIndex = -1;
  dynClampTask.running = 1;
#ifdef ENABLE_STATISTICS
  dynClampTask.currenttime = rt_get_cpu_time_ns();
  dynClampTask.sumperiod = 0;
  dynClampTask.sumsqperiod = 0;
  dynClampTask.minperiod = 10*dynClampTask.periodLengthNs;
  dynClampTask.maxperiod = 0;
#endif

#ifdef ENABLE_SYNCSEC
  difftime = dynClampTask.periodLengthNs;
#endif

#ifdef ENABLE_COMPUTATION
  // initialize model-specific variables:
  initModel();
#endif

  /* Somehow the first time this function waits for nothing... */
  rt_task_wait_period();
  
  /**************************************************************************/
  /******** LOOP START: *****************************************************/
  /**************************************************************************/
  while( subdevRunning ) {
    
    subdevRunning = 0;

#ifdef ENABLE_TTLPULSE
    for ( iT = 0; iT < MAXTTLPULSES && ttlStartWriteInsn[iT] != 0; iT++ ) {
      retVal = comedi_do_insn( device, ttlStartWriteInsn[iT] );
      if ( retVal < 1 ) {
	if ( retVal < 0 )
	  comedi_perror( "dynclampmodule: rtDynClamp ttl pulse at start write: comedi_do_insn" );
	ERROR_MSG( "dynclampmodule: ERROR! failed to write TTL pulse %d at start write\n", iT );
      }
    }
#endif

#ifdef ENABLE_SYNCSEC
    if ( syncSECPulse > 0 )
      currentfac = difftime / syncSECPulse;
    else
      currentfac = 1.0;
#endif

    /******** WRITE TO ANALOG OUTPUT: ******************************************/
    /****************************************************************************/
    if ( aosubdev != 0 ) {

      // check for pending start trigger:
      if ( aosubdev->running && aosubdev->pending ) {
	DEBUG_MSG( "REALTIMELOOP PENDING AO startsrc=%d, prevtriger1=%d, triger1=%d, pv=%d, v=%d\n",
		   aosubdev->startsource, prevtriggerevs[1], triggerevs[1],
		   (int)(100.0*subdev[0].chanlist[0].prevvoltage), (int)(100.0*subdev[0].chanlist[0].voltage) );
	if ( triggerevs[aosubdev->startsource] &&
	     ! prevtriggerevs[aosubdev->startsource] ) {
	  DEBUG_MSG( "REALTIMELOOP PENDING AO SETUP duration=%lu, loopCnt=%lu\n", aosubdev->duration, dynClampTask.loopCnt );
	  aosubdev->delay = dynClampTask.loopCnt + aosubdev->delay; 
	  aosubdev->duration = aosubdev->delay + aosubdev->duration;
	  dynClampTask.aoIndex = aosubdev->delay + 1;
	  aosubdev->pending = 0;
	  DEBUG_MSG( "REALTIMELOOP PENDING AO STARTED duration=%lu delay=%lu, loopCnt=%lu\n", aosubdev->duration, aosubdev->delay, dynClampTask.loopCnt );
#ifdef ENABLE_TTLPULSE
	  for ( iT = 0; iT < MAXTTLPULSES && ttlStartAOInsn[iT] != 0; iT++ ) {
	    retVal = comedi_do_insn( device, ttlStartAOInsn[iT] );
	    if ( retVal < 1 ) {
	      if ( retVal < 0 )
		comedi_perror( "dynclampmodule: rtDynClamp ttl pulse at start ao: comedi_do_insn" );
	      ERROR_MSG( "dynclampmodule: ERROR! failed to write TTL pulse %d at start ao\n", iT );
	    }
	  }
#endif
	}
      }

      if ( aosubdev->running && ! aosubdev->pending ) {
	  
	// check end of stimulus:
	if ( !aosubdev->continuous &&
	     aosubdev->duration <= dynClampTask.loopCnt ) {
	  SDEBUG_MSG( "dynclampmodule: finished ao subdevice at loop %lu\n", dynClampTask.loopCnt );
	  rtf_reset( aosubdev->fifo );
	  stopSubdevice( aosubdev, /*kill=*/0 );
#ifdef ENABLE_TTLPULSE
	  for ( iT = 0; iT < MAXTTLPULSES && ttlEndAOInsn[iT] != 0; iT++ ) {
	    retVal = comedi_do_insn( device, ttlEndAOInsn[iT] );
	    if ( retVal < 1 ) {
	      if ( retVal < 0 )
		comedi_perror( "dynclampmodule: rtDynClamp ttl pulse at end ao: comedi_do_insn" );
	      ERROR_MSG( "dynclampmodule: ERROR! failed to write TTL pulse %d at end ao\n", iT );
	    }
	  }
#endif
	}
	else if ( dynClampTask.loopCnt >= aosubdev->delay ) {
	  // read output from FIFO:
	  for ( iC = 0; iC < aosubdev->chanN; iC++ ) {
	    pChan = &aosubdev->chanlist[iC];
	    if ( pChan->isUsed ) {
	      // get data from FIFO:
	      retVal = rtf_get( pChan->fifo, &pChan->voltage, sizeof(float) );
	      if ( retVal != sizeof(float) ) {
		if ( retVal == EINVAL ) {
		  ERROR_MSG( "dynclampmodule: ERROR! No open FIFO for AO subdevice at loopCnt %lu\n", dynClampTask.loopCnt );
		  ERROR_MSG( "Stop dynClampTask." );
		  dynClampTask.running = 0;
		  dynClampTask.duration = 0;
		  return;
		}
		aosubdev->error = E_UNDERRUN;
		ERROR_MSG( "dynclampmodule: ERROR! Data buffer underrun for AO subdevice at loopCnt %lu\n", dynClampTask.loopCnt );
		aosubdev->running = 0;
		continue;
	      }
#ifdef ENABLE_COMPUTATION
	      if ( pChan->isParamChan ) {
		paramOutput[pChan->chan] = pChan->voltage;
	      }
#endif
	    }
	  }
	}

      }  // aosubdev->running && ! aosubdev->pending
	
      subdevRunning = 1;
	
      // write output to daq board:
      for ( iC = 0; iC < aosubdev->chanN; iC++ ) {
	pChan = &aosubdev->chanlist[iC];
	// this is an output to the DAQ board:
#ifdef ENABLE_COMPUTATION
	if ( !pChan->isParamChan ) {
#endif
	  voltage = pChan->voltage;
#ifdef ENABLE_COMPUTATION
	  // add model output to sample:
	  if ( pChan->modelIndex >= 0 )
	    voltage += output[pChan->modelIndex];
#endif
	  // write out Sample:
#ifdef ENABLE_SYNCSEC
	  voltage *= currentfac;
#endif
	  value_to_sample( pChan, voltage ); // sets pChan->lsample
	  retVal = comedi_do_insn( device, &pChan->insn );
	  if ( retVal < 1 ) {
	    aosubdev->running = 0;
	    aosubdev->error = E_NODATA;
	    ERROR_MSG( "dynclampmodule: ERROR! failed to write data to AO subdevice channel %d at loopCnt %lu\n",
		       iC, dynClampTask.loopCnt );
	    if ( retVal < 0 ) {
	      comedi_perror( "dynclampmodule: rtDynClamp: comedi_data_write" );
	      aosubdev->error = E_COMEDI;
	      aosubdev->running = 0;
	      ERROR_MSG( "dynclampmodule: ERROR! failed to write to AO subdevice channel %d at loopCnt %lu\n",
			 iC, dynClampTask.loopCnt );
	    }
	  }
#ifdef ENABLE_COMPUTATION
	}
#endif
      } // end of chan loop

    } // analog output available


#ifdef ENABLE_TTLPULSE
    for ( iT = 0; iT < MAXTTLPULSES && ttlEndWriteInsn[iT] != 0; iT++ ) {
      retVal = comedi_do_insn( device, ttlEndWriteInsn[iT] );
      if ( retVal < 1 ) {
	if ( retVal < 0 )
	  comedi_perror( "dynclampmodule: rtDynClamp ttl pulse at end write: comedi_do_insn" );
	ERROR_MSG( "dynclampmodule: ERROR! failed to write TTL pulse %d at end write\n", iT );
      }
    }
#endif


#ifdef ENABLE_SYNCSEC
    if ( syncSECInsnHigh.subdev >= 0 ) {
      retVal = comedi_do_insn( device, &syncSECInsnHigh );
      if ( retVal < 1 ) {
	if ( retVal < 0 )
	  comedi_perror( "dynclampmodule: rtDynClamp seting DIO high at start write for syncing SEC: comedi_do_insn" );
	ERROR_MSG( "dynclampmodule: ERROR! failed to set DIO high at start write for syncing SEC\n" );
      }
    }

#else

    /******** SLEEP FOR NEURON TO REACT TO GIVEN OUTPUT: ************************/
    /****************************************************************************/
    // PROBLEM: rt_sleep is timed using jiffies only (granularity = 1msec)
	// int retValSleep = rt_sleep( nano2count( INJECT_RECORD_DELAY ) );
    rt_busy_sleep( INJECT_RECORD_DELAY ); // TODO: just default

#endif

#ifdef ENABLE_TTLPULSE
    for ( iT = 0; iT < MAXTTLPULSES && ttlStartReadInsn[iT] != 0; iT++ ) {
      retVal = comedi_do_insn( device, ttlStartReadInsn[iT] );
      if ( retVal < 1 ) {
	if ( retVal < 0 )
	  comedi_perror( "dynclampmodule: rtDynClamp ttl pulse at start read: comedi_do_insn" );
	ERROR_MSG( "dynclampmodule: ERROR! failed to write TTL pulse %d at start read\n", iT );
      }
    }
#endif
    
    /******** FROM ANALOG INPUT: **********************************************/
    /****************************************************************************/
    if ( aisubdev != 0 && aisubdev->running ) {
	
      if ( aisubdev->pending ) {
	if ( triggerevs[aisubdev->startsource] &&
	     ! prevtriggerevs[aisubdev->startsource] ) {
	  aisubdev->delay = dynClampTask.loopCnt + aisubdev->delay; 
	  aisubdev->duration = aisubdev->delay + aisubdev->duration;
	  aisubdev->pending = 0;
	}
	else
	  continue;
      }
          
      // check duration:
      if ( !aisubdev->continuous &&
	   aisubdev->duration <= dynClampTask.loopCnt ) {
	stopSubdevice( aisubdev, /*kill=*/0 );
      }
      subdevRunning = 1;

      // for every ai channel:
      for ( iC = 0; iC < aisubdev->chanN; iC++ ) {

	pChan = &aisubdev->chanlist[iC];

	// previous sample:
	pChan->prevvoltage = pChan->voltage;

	// acquire sample:
#ifdef ENABLE_COMPUTATION
	if ( !pChan->isParamChan ) {
#endif
	  retVal = comedi_do_insn( device, &pChan->insn );     
	  if ( retVal < 1 ) {
	    aisubdev->running = 0;
	    aisubdev->error = E_NODATA;
	    ERROR_MSG( "dynclampmodule: ERROR! failed to read data from AI subdevice channel %d at loopCnt %lu\n",
		       iC, dynClampTask.loopCnt );
	    if ( retVal < 0 ) {
	      comedi_perror( "dynclampmodule: rtDynClamp: comedi_data_read" );
	      aisubdev->running = 0;
	      aisubdev->error = E_COMEDI;
	      ERROR_MSG( "dynclampmodule: ERROR! failed to read from AI subdevice channel %d at loopCnt %lu\n",
			 iC, dynClampTask.loopCnt );
	      continue;
	    }
	  }
	  // convert to voltage:
	  sample_to_value( pChan ); // sets pChan->voltage from pChan->lsample

#ifdef ENABLE_COMPUTATION
	  if ( pChan->modelIndex >= 0 )
	    input[pChan->modelIndex] = pChan->voltage;
	}
	else {
	  pChan->voltage = paramInput[pChan->chan];
	}
#endif
	  
	// debug:
	if ( aisubdev->running == 0 )
	  ERROR_MSG( "dynclampmodule: ERROR! ai subdevice somehow not running\n" );
	// write to FIFO:
	retVal = rtf_put( pChan->fifo, &pChan->voltage, sizeof(float) );
	// debug:
	if ( aisubdev->running == 0 )
	  ERROR_MSG( "dynclampmodule: ERROR! rtf_put turned ai subdevice not running\n" );

	if ( retVal != sizeof(float) ) {
	  ERROR_MSG( "dynclampmodule: ERROR! rtf_put failed, return value=%d\n", retVal );
	  if ( retVal == EINVAL ) {
	    ERROR_MSG( "dynclampmodule: ERROR! No open FIFO for AI subdevice at loopCnt %lu\n", dynClampTask.loopCnt );
	    ERROR_MSG( "Stop dynClampTask." );
	    dynClampTask.running = 0;
	    dynClampTask.duration = 0;
	    return;
	  }
	  aisubdev->error = E_OVERFLOW;
	  ERROR_MSG( "dynclampmodule: ERROR! FIFO buffer overflow for AI subdevice at loopCnt %lu\n",
		     dynClampTask.loopCnt );
	  aisubdev->running = 0;
	  continue;
	}

	if ( aisubdev->running == 0 )
	  ERROR_MSG( "dynclampmodule: ERROR! rtf_put error handling turned ai subdevice not running\n" );

#ifdef ENABLE_TRIGGER
	// trigger:
	if ( pChan->trigger ) {
	  prevtriggerevs[1] = triggerevs[1];
	  if ( pChan->voltage > pChan->alevel && pChan->prevvoltage <= pChan->alevel ) {
	    triggerevs[1] = 1;
	  }
	  else if ( pChan->voltage < pChan->alevel && pChan->prevvoltage >= pChan->alevel ) {
	    triggerevs[1] = 0;
	  }
	}
#endif
	  
      } // end of chan loop
      readCnt++; // FOR DEBUG
    } // analog input available

#ifdef ENABLE_SYNCSEC
    if ( syncSECInsnLow.subdev >= 0 ) {
      retVal = comedi_do_insn( device, &syncSECInsnLow );
      if ( retVal < 1 ) {
	if ( retVal < 0 )
	  comedi_perror( "dynclampmodule: rtDynClamp seting DIO low at start write for syncing SEC: comedi_do_insn" );
	ERROR_MSG( "dynclampmodule: ERROR! failed to set DIO low at start write for syncing SEC\n" );
      }
    }
#endif

#ifdef ENABLE_TTLPULSE
    for ( iT = 0; iT < MAXTTLPULSES && ttlEndReadInsn[iT] != 0; iT++ ) {
      retVal = comedi_do_insn( device, ttlEndReadInsn[iT] );
      if ( retVal < 1 ) {
	if ( retVal < 0 )
	  comedi_perror( "dynclampmodule: rtDynClamp ttl pulse at end read: comedi_do_insn" );
	ERROR_MSG( "dynclampmodule: ERROR! failed to write TTL pulse %d at end read\n", iT );
      }
    }
#endif


    /****************************************************************************/
#ifdef ENABLE_COMPUTATION
    computeModel();
#endif

    /******** WAIT FOR CALCULATION TASK TO COMPUTE RESULT: **********************/
    /****************************************************************************/
    dynClampTask.loopCnt++;

    //    start = rt_get_cpu_time_ns();
    rt_task_wait_period();

#if defined(ENABLE_STATISTICS) || defined(ENABLE_SYNCSEC)
    newtime = rt_get_cpu_time_ns();
    difftime = newtime - dynClampTask.currenttime;
    dynClampTask.currenttime = newtime;
#endif

#ifdef ENABLE_STATISTICS
    /*" XXX Unknown symbol __divdi3: use rtai_ulldiv() from include/asm-i386/rtai_hal.h !!! */
    dynClampTask.sumperiod += difftime;
    dynClampTask.sumsqperiod += difftime*difftime;
    if ( dynClampTask.minperiod > difftime )
      dynClampTask.minperiod = difftime;
    if ( dynClampTask.maxperiod < difftime )
      dynClampTask.maxperiod = difftime;
#endif

  } // END OF DYNCLAMP LOOP
    
  dynClampTask.running = 0;
  dynClampTask.duration = 0;

  SDEBUG_MSG( "dynclampmodule: left dynamic clamp loop after %lu cycles\n",
	      dynClampTask.loopCnt );
}


///////////////////////////////////////////////////////////////////////////////
// *** RTAI FUNCTIONS ***
///////////////////////////////////////////////////////////////////////////////


// TODO: seperate into init and start?
int init_rt_task( void )
{
  int stackSize = 16384;
  int priority;
  int usesFPU = 1;   /* we need FPU support in any case! */
  void* signal = NULL;
  int dummy = 23;
  int retVal;
  RTIME periodTicks;

  DEBUG_MSG( "init_rt_task: Trying to initialize dynamic clamp RTAI task...\n" );

#ifndef CONFIG_RTAI_FPU_SUPPORT
  #error "RTAI FPU support is not enabled. Reconfigure, compile and install RTAI kernel modules."
#endif

  // test if dynamic clamp frequency is valid:
  if ( dynClampTask.reqFreq <= 0 || dynClampTask.reqFreq > MAX_FREQUENCY ) {
    ERROR_MSG( "init_rt_task ERROR: %dHz -> invalid dynamic clamp frequency. Valid range is 1 .. %dHz\n", 
	       dynClampTask.reqFreq, MAX_FREQUENCY );
    return -1;
  }

  // initializing rt-task for dynamic clamp with high priority:
  priority = RT_SCHED_HIGHEST_PRIORITY;
  rt_linux_use_fpu( usesFPU );      /* declare if we use the FPU         */
  retVal = rt_task_init( &dynClampTask.rtTask, rtDynClamp, dummy, stackSize, 
			 priority, usesFPU, signal );
  if ( retVal ) {
    ERROR_MSG( "init_rt_task ERROR: failed to initialize real-time task for dynamic clamp! stacksize was set to %d bytes.\n", 
	       stackSize );
    return -1;
  }
  DEBUG_MSG( "init_rt_task: Initialized dynamic clamp RTAI task. Trying to make it periodic...\n" );

    // START rt-task for dynamic clamp as periodic:
  periodTicks = start_rt_timer( nano2count( 1000000000/dynClampTask.reqFreq ) );  
  if ( rt_task_make_periodic( &dynClampTask.rtTask, rt_get_time(), periodTicks ) 
      != 0 ) {
    printk( "init_rt_task ERROR: failed to start periodic real-time task for data acquisition! loading of module failed!\n" );
    return -3;
  }
  dynClampTask.periodLengthNs = count2nano( periodTicks );
  dynClampTask.setFreq = 1000000000 / dynClampTask.periodLengthNs;
#ifdef ENABLE_COMPUTATION
  loopInterval = 1.0e-9*dynClampTask.periodLengthNs;
  loopRate = 1.0e9/dynClampTask.periodLengthNs;
#endif
  INFO_MSG( "init_rt_task: periodic task successfully started... requested freq: %d , accepted freq: ~%u (period=%uns)\n", 
	    dynClampTask.reqFreq, dynClampTask.setFreq, dynClampTask.periodLengthNs );

  // For now, the DynClampTask shall always run until any subdev is stopped:
  dynClampTask.continuous = 1;

  return 0;
}

// TODO: add stop_rt_task?
void cleanup_rt_task( void )
{
  stop_rt_timer();
  DEBUG_MSG( "cleanup_rt_task: stopped periodic task\n" );

  rt_task_delete( &dynClampTask.rtTask );
  memset( &dynClampTask, 0, sizeof(struct dynClampTaskT) );
}





///////////////////////////////////////////////////////////////////////////////
// *** IOCTL ***
///////////////////////////////////////////////////////////////////////////////

#ifdef HAVE_UNLOCKED_IOCTL
long rtmodule_unlocked_ioctl( struct file *fModule, unsigned int cmd,
			      unsigned long arg )
#else
int rtmodule_ioctl( struct inode *devFile, struct file *fModule, 
		    unsigned int cmd, unsigned long arg )
#endif
{
  static struct deviceIOCT deviceIOC;
  static struct chanlistIOCT chanlistIOC;
  static struct syncCmdIOCT syncCmdIOC;
#ifdef ENABLE_COMPUTATION
  static struct traceInfoIOCT traceInfo;
  static struct traceChannelIOCT traceChannel;
#endif
  static struct dioIOCT dioIOC;
  static struct triggerIOCT triggerIOC;

  int tmp, subdevID;
  int retVal;
  int rc = 0;
  unsigned long luTmp;


  if ( _IOC_TYPE(cmd) != RTMODULE_MAJOR || _IOC_NR(cmd) > RTMODULE_IOC_MAXNR) {
    ERROR_MSG( " ioctl: Major wrong or ioctl %d bigger than max %d\n", 
	       _IOC_TYPE(cmd), RTMODULE_IOC_MAXNR );
    return -ENOTTY;
  }
  DEBUG_MSG( "ioctl: user triggered ioctl %d %s\n",_IOC_NR( cmd ), iocNames[_IOC_NR( cmd )] );

  mutex_lock( &mutex );

  switch( cmd ) {
    

    /******** GIVE INFORMATION TO USER SPACE: ***********************************/
    
  case IOC_GETRATE:
    tmp = dynClampTask.setFreq;
    retVal = put_user( tmp, (int __user *)arg );
    rc = retVal == 0 ? 0 : -EFAULT;
    break;

  case IOC_GETAOINDEX:
    luTmp = dynClampTask.aoIndex;
    if ( luTmp < 0 ) {
      rc = -ENOSPC;
      break;
    }
    retVal = put_user( luTmp, (unsigned long __user *)arg );
    rc = retVal == 0 ? 0 : -EFAULT;
    break;

  case IOC_GETLOOPCNT:
    luTmp = dynClampTask.loopCnt;
    if ( luTmp < 0 ) {
      rc = -ENOSPC;
      break;
    }
    retVal = put_user( luTmp, (unsigned long __user *)arg );
    rc = retVal == 0 ? 0 : -EFAULT;
    break;

#ifdef ENABLE_STATISTICS
  case IOC_GETLOOPAVG:
    if ( dynClampTask.loopCnt > 0 )
      luTmp = dynClampTask.sumperiod/dynClampTask.loopCnt;
      /*" XXX Unknown symbol __divdi3: use rtai_ulldiv() from include/asm-i386/rtai_hal.h !!! */
    else
      luTmp = -1;
    if ( luTmp < 0 ) {
      rc = -ENOSPC;
      break;
    }
    retVal = put_user( luTmp, (unsigned long __user *)arg );
    rc = retVal == 0 ? 0 : -EFAULT;
    break;

  case IOC_GETLOOPSQAVG:
    if ( dynClampTask.loopCnt > 0 )
      luTmp = dynClampTask.sumsqperiod/dynClampTask.loopCnt;
      /*" XXX Unknown symbol __divdi3: use rtai_ulldiv() from include/asm-i386/rtai_hal.h !!! */
    else
      luTmp = -1;
    if ( luTmp < 0 ) {
      rc = -ENOSPC;
      break;
    }
    retVal = put_user( luTmp, (unsigned long __user *)arg );
    rc = retVal == 0 ? 0 : -EFAULT;
    break;

  case IOC_GETLOOPMIN:
    luTmp = dynClampTask.minperiod;
    if ( dynClampTask.loopCnt < 1 ) {
      rc = -ENOSPC;
      break;
    }
    retVal = put_user( luTmp, (unsigned long __user *)arg );
    rc = retVal == 0 ? 0 : -EFAULT;
    break;

  case IOC_GETLOOPMAX:
    luTmp = dynClampTask.maxperiod;
    if ( dynClampTask.loopCnt < 1 ) {
      rc = -ENOSPC;
      break;
    }
    retVal = put_user( luTmp, (unsigned long __user *)arg );
    rc = retVal == 0 ? 0 : -EFAULT;
    break;
#endif

    /******** SET UP COMEDI: ****************************************************/

  case IOC_GET_SUBDEV_ID:
    tmp = getSubdevID();
    if ( tmp < 0 ) {
      rc = -ENOSPC;
      break;
    }
    retVal = put_user( tmp, (int __user *)arg );
    rc = retVal == 0 ? 0 : -EFAULT;
    break;

  case IOC_OPEN_SUBDEV:
    retVal = copy_from_user( &deviceIOC, (void __user *)arg, sizeof(struct deviceIOCT) );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to deviceIOCT-struct!\n" );
      rc = -EFAULT;
      break;
    }
    if ( deviceIOC.subdevID >= subdevN ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid subdevice ID in deviceIOCT-struct!\n" );
      rc = -EFAULT;
      break;
    }
    retVal = openComediDevice( &deviceIOC );
    if ( retVal != 0 ) {
      rc = -EFAULT;
      break;
    }
    retVal = copy_to_user( (void __user *)arg, &deviceIOC, sizeof(struct deviceIOCT) );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to deviceIOCT-struct!\n" );
      rc = -EFAULT;
      break;
    }
    rc = 0;
    break;

  case IOC_CHANLIST:
    retVal = copy_from_user( &chanlistIOC, (void __user *)arg, sizeof(struct chanlistIOCT) );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to chanlistIOCT-struct!\n" );
      rc = -EFAULT;
      break;
    }
    if ( chanlistIOC.subdevID >= subdevN ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid subdevice ID in chanlistIOCT-struct!\n" );
      rc = -EFAULT;
      break;
    }
    retVal = loadChanlist( &chanlistIOC );
    rc = retVal == 0 ? 0 : -EFAULT;
    break;

  case IOC_SYNC_CMD:
    retVal = copy_from_user( &syncCmdIOC, (void __user *)arg, sizeof(struct syncCmdIOCT) );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to syncCmdIOCT-struct!\n" );
      rc = -EFAULT;
      break;
    }
    if ( syncCmdIOC.subdevID >= subdevN ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid subdevice ID in syncCmdIOCT-struct!\n" );
      rc = -EFAULT;
      break;
    }
    retVal = loadSyncCmd( &syncCmdIOC );
    rc = retVal;
    break;


  case IOC_GET_TRACE_INFO:
#ifdef ENABLE_COMPUTATION
    retVal = copy_from_user( &traceInfo, (void __user *)arg, sizeof(struct traceInfoIOCT) );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid user pointer for traceInfoIOCT!\n" );
      rc = -EFAULT;
      break;
    }
    rc = 0;
    switch( traceInfo.traceType ) {
    case TRACE_IN:
      if ( traceIndex >= INPUT_N ) {
	traceIndex = 0;
	rc = -ERANGE; // signal end of list
	break;
      }
      strncpy( traceInfo.name, inputNames[traceIndex], PARAM_NAME_MAXLEN );
      strncpy( traceInfo.unit, inputUnits[traceIndex], PARAM_NAME_MAXLEN );
      break;
    case TRACE_OUT:
      if ( traceIndex >= OUTPUT_N ) {
	traceIndex = 0;
	rc = -ERANGE; // signal end of list
	break;
      }
      strncpy( traceInfo.name, outputNames[traceIndex], PARAM_NAME_MAXLEN );
      strncpy( traceInfo.unit, outputUnits[traceIndex], PARAM_NAME_MAXLEN );
      break;
    case PARAM_IN:
      if ( traceIndex >= PARAMINPUT_N ) {
	traceIndex = 0;
	rc = -ERANGE; // signal end of list
	break;
      }
      strncpy( traceInfo.name, paramInputNames[traceIndex], PARAM_NAME_MAXLEN );
      strncpy( traceInfo.unit, paramInputUnits[traceIndex], PARAM_NAME_MAXLEN );
      break;
    case PARAM_OUT:
      if ( traceIndex >= PARAMOUTPUT_N ) {
	traceIndex = 0;
	rc = -ERANGE; // signal end of list
	break;
      }
      strncpy( traceInfo.name, paramOutputNames[traceIndex], PARAM_NAME_MAXLEN );
      strncpy( traceInfo.unit, paramOutputUnits[traceIndex], PARAM_NAME_MAXLEN );
      break;
    default: ;
    }
    if ( rc != 0 )
      break;
    retVal = copy_to_user( (void __user *)arg, &traceInfo, sizeof(struct traceInfoIOCT) );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid user pointer for traceInfoIOCT!\n" );
      rc = -EFAULT;
      break;
    }
    traceIndex++;
    rc = 0;
    break;
#else
    rc = -ERANGE; // signal end of list
    break;
#endif

  case IOC_SET_TRACE_CHANNEL:
#ifdef ENABLE_COMPUTATION
    retVal = copy_from_user( &traceChannel, (void __user *)arg, sizeof(struct traceChannelIOCT) );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid user pointer for traceChannelIOCT!\n" );
      rc = -EFAULT;
      break;
    }
    switch( traceChannel.traceType ) {
    case TRACE_IN:
      inputDevices[chanIndex] = traceChannel.device;
      inputChannels[chanIndex] = traceChannel.channel;
      break;
    case TRACE_OUT:
      outputDevices[chanIndex] = traceChannel.device;
      outputChannels[chanIndex] = traceChannel.channel;
      break;
    default: ;
    }
    chanIndex++;
    if ( chanIndex >= INPUT_N )
      chanIndex = 0;
    rc = 0;
    break;
#else
    rc = -EFAULT; // Nothing done
    break;
#endif


  case IOC_START_SUBDEV:
    retVal = get_user( subdevID, (int __user *)arg );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to subdevice ID for start-query!" );
      rc = -EFAULT;
      break;
    }
    if ( subdevID >= subdevN ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid subdevice ID for start-query!\n" );
      rc = -EFAULT;
      break;
    }
    retVal = startSubdevice( subdevID );
    rc = retVal;
    break;


  case IOC_CHK_RUNNING:
    retVal = get_user( subdevID, (int __user *)arg );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to subdevice ID for running-query!" );
      rc = -EFAULT;
      break;
    }
    if ( subdevID >= subdevN ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid subdevice ID for running-query!\n" );
      rc = -EFAULT;
      break;
    }
    tmp = subdev[subdevID].running;
    DEBUG_MSG( "dynclampmodule_ioctl: running = %d for subdevID %d\n", tmp, subdevID );
    retVal = put_user( tmp, (int __user *)arg );
    rc = retVal == 0 ? 0 : -EFAULT;
    break;


  case IOC_REQ_CLOSE:
    retVal = get_user( subdevID, (int __user *)arg );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to subdevice ID for close-request!" );
      rc = -EFAULT;
      break;
    }
    if ( subdevID >= subdevN ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid subdevice ID for close-request!\n" );
      rc = -EFAULT;
      break;
    }
    if ( reqCloseSubdevID >= 0 ) {
      ERROR_MSG( "dynclampmodule_ioctl IOC_REQ_CLOSE ERROR: Another close-request in progress!\n" );
      rc = -EAGAIN;
      break;
    }
    reqCloseSubdevID = subdevID;
    rc = 0;
    break;

  case IOC_REQ_READ: // Noch wichtig fuer tracename-List?
    retVal = get_user( subdevID, (int __user *)arg );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to subdevice ID for read-request!" );
      rc = -EFAULT;
      break;
    }
    if ( subdevID >= subdevN ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid subdevice ID for read-request!\n" );
      rc = -EFAULT;
      break;
    }
    if ( reqTraceSubdevID >= 0 ) {
      ERROR_MSG( "dynclampmodule_ioctl IOC_REQ_READ ERROR: Another read-request in progress! (reqTraceSubdevID=%d)\n", reqTraceSubdevID );
      rc = -EAGAIN;
      break;
    }
    ERROR_MSG( "dynclampmodule_ioctl IOC_REQ_READ: Requested Read\n" );
    reqTraceSubdevID = subdevID;
    rc = 0;
    break;


  case IOC_STOP_SUBDEV:
    retVal = get_user( subdevID, (int __user *)arg );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to subdevice ID for stop-query!" );
      rc = -EFAULT;
      break;
    }
    if ( subdevID >= subdevN ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid subdevice ID for stop-query!\n" );
      rc = -EFAULT;
      break;
    }
    SDEBUG_MSG( "ioctl: user requests to stop and potentially kill subdevice %d\n", subdevID );
    retVal = stopSubdevice( &subdev[subdevID], /*kill=*/1 );
    DEBUG_MSG( "dynclampmodule_ioctl: stopSubdevice returned %u\n", retVal );
    rc = retVal == 0 ? 0 : -EFAULT;
    break;


  case IOC_RELEASE_SUBDEV:
    retVal = get_user( subdevID, (int __user *)arg );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to subdevice ID for release-query!" );
      rc = -EFAULT;
      break;
    }
    if ( subdevID >= subdevN ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid subdevice ID for release-query!\n" );
      rc = -EFAULT;
      break;
    }
    SDEBUG_MSG( "ioctl: user requests to release subdevice %d\n", subdevID );
    releaseSubdevice( subdevID );
    rc = 0;
    break;


    // ******* Digital IO: ********************************************
  case IOC_DIO_CMD:
    retVal = copy_from_user( &dioIOC, (void __user *)arg, sizeof(struct dioIOCT) );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to dioIOCT-struct!\n" );
      rc = -EFAULT;
      break;
    }
    if ( dioIOC.subdevID >= subdevN ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid subdevice ID in dioIOCT-struct!\n" );
      rc = -EFAULT;
      break;
    }
    retVal = setDigitalIO( &dioIOC );
    if ( retVal != 0 ) {
      rc = retVal;
      break;
    }
    retVal = copy_to_user( (void __user *)arg, &dioIOC, sizeof(struct dioIOCT) );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to dioIOCT-struct!\n" );
      rc = -EFAULT;
      break;
    }
    rc = 0;
    break;

    // ******* Trigger: ***********************************************

  case IOC_SET_TRIGGER:
    retVal = copy_from_user( &triggerIOC, (void __user *)arg, sizeof(struct triggerIOCT) );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to triggerIOCT-struct!\n" );
      rc = -EFAULT;
      break;
    }
    rc = setAnalogTrigger( &triggerIOC );
    break;

  case IOC_UNSET_TRIGGER:
    retVal = copy_from_user( &triggerIOC, (void __user *)arg, sizeof(struct triggerIOCT) );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to triggerIOCT-struct!\n" );
      rc = -EFAULT;
      break;
    }
    rc = unsetAnalogTrigger( &triggerIOC );
    break;


#ifdef ENABLE_COMPUTATION
#ifdef ENABLE_LOOKUPTABLES
    // ******* Lookup tables: ***********************************************

  case IOC_SET_LOOKUP_K:
    retVal = get_user( lookupinx, (int __user *)arg );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to lookup index!" );
      lookupinx = -1;
      rc = -EFAULT;
      break;
    }
    if ( lookupinx < 0 || lookupinx >= MAXLOOKUPTABLES ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid lookup index!" );
      lookupinx = -1;
      rc = -EINVAL;
      break;
    }
    lookupn[lookupinx] = 0;
    if ( lookupx[lookupinx] != NULL )
      kfree( lookupx[lookupinx] );
    if ( lookupy[lookupinx] != NULL )
      kfree( lookupy[lookupinx] );
    lookupx[lookupinx] = NULL;
    lookupy[lookupinx] = NULL;
    break;

  case IOC_SET_LOOKUP_N:
    if ( lookupinx < 0 ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid lookup index!" );
      rc = -EINVAL;
      break;
    }
    retVal = get_user( lookupn[lookupinx], (int __user *)arg );
    if ( retVal ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to size of lookup table!" );
      lookupn[lookupinx] = 0;
      rc = -EFAULT;
    }
    break;

  case IOC_SET_LOOKUP_X:
    if ( lookupinx < 0 ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid lookup index!" );
      rc = -EINVAL;
      break;
    }
    if ( lookupx[lookupinx] != NULL ) {
      kfree( lookupx[lookupinx] );
      lookupx[lookupinx] = NULL;
    }
    if ( lookupn[lookupinx] > 0 ) {
      lookupx[lookupinx] = kmalloc( lookupn[lookupinx]*sizeof(float), GFP_KERNEL );
      if ( lookupx[lookupinx] == NULL ) {
	ERROR_MSG( "dynclampmodule_ioctl ERROR: failed to allocate memory for x-array of lookup table!\n" );
	rc = -ENOMEM;
      }
      else {
	retVal = copy_from_user( lookupx[lookupinx], (void __user *)arg,
				 lookupn[lookupinx]*sizeof(float) );
	if ( retVal ) {
	  ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to x-array of lookup table!\n" );
	  rc = -EFAULT;
	}
      }
      if ( rc != 0 ) {
	if ( lookupx[lookupinx] != NULL ) {
	  kfree( lookupx[lookupinx] );
	  lookupx[lookupinx] = NULL;
	}
	if ( lookupy[lookupinx] != NULL ) {
	  kfree( lookupy[lookupinx] );
	  lookupy[lookupinx] = NULL;
	}
	lookupn[lookupinx] = 0;
      }
    }
    break;

  case IOC_SET_LOOKUP_Y:
    if ( lookupinx < 0 ) {
      ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid lookup index!" );
      rc = -EINVAL;
      break;
    }
    if ( lookupy[lookupinx] != NULL ) {
      kfree( lookupy[lookupinx] );
      lookupy[lookupinx] = NULL;
    }
    if ( lookupn[lookupinx] > 0 ) {
      lookupy[lookupinx] = kmalloc( lookupn[lookupinx]*sizeof(float), GFP_KERNEL );
      if ( lookupy[lookupinx] == NULL ) {
	ERROR_MSG( "dynclampmodule_ioctl ERROR: failed to allocate memory for y-array of lookup table!\n" );
	rc = -ENOMEM;
      }
      else {
	retVal = copy_from_user( lookupy[lookupinx], (void __user *)arg,
				 lookupn[lookupinx]*sizeof(float) );
	if ( retVal ) {
	  ERROR_MSG( "dynclampmodule_ioctl ERROR: invalid pointer to y-array of lookup table!\n" );
	  rc = -EFAULT;
	}
      }
      if ( rc != 0 ) {
	if ( lookupx[lookupinx] != NULL ) {
	  kfree( lookupx[lookupinx] );
	  lookupx[lookupinx] = NULL;
	}
	if ( lookupy[lookupinx] != NULL ) {
	  kfree( lookupy[lookupinx] );
	  lookupy[lookupinx] = NULL;
	}
	lookupn[lookupinx] = 0;
      }
    }
    break;

#endif
#endif

  default:
    ERROR_MSG( "dynclampmodule_ioctl ERROR - Invalid IOCTL!\n" );
    rc = -ENOTTY;

  }

  mutex_unlock( &mutex );

  return rc;
}



///////////////////////////////////////////////////////////////////////////////
// *** DRIVER FUNCTIONS ***
///////////////////////////////////////////////////////////////////////////////

int rtmodule_open( struct inode *devFile, struct file *fModule )
{
  DEBUG_MSG( "======================================\n" );
  DEBUG_MSG( "rtmodule_open: user opened device file\n" );
  
  return 0;
}


int rtmodule_close( struct inode *devFile, struct file *fModule )
{
  int iS;
  // no subdevice specified? => stop & close all subdevices & comedi-devices:
  if ( reqCloseSubdevID < 0 ) {
    DEBUG_MSG( "close: no IOC_REQ_CLOSE request received - closing all subdevices...\n" );
    mutex_lock( &mutex );
    for ( iS = 0; iS < subdevN; iS++ ) {
      if ( stopSubdevice( &subdev[iS], /*kill=*/1 ) )
        WARN_MSG( "dynclampmodule_close: Stopping subdevice with ID %d failed\n", iS );
      releaseSubdevice( iS );
    }
    mutex_unlock( &mutex );
    init_globals();
    return 0;
  }

  // stop & close specified subdevice (and device):
  mutex_lock( &mutex );
  if ( stopSubdevice( &subdev[reqCloseSubdevID], 1 ) )
    WARN_MSG( "dynclampmodule_close: Stopping subdevice with ID %d failed\n", reqCloseSubdevID );
  releaseSubdevice( reqCloseSubdevID );
  mutex_unlock( &mutex );

  init_globals();

  reqCloseSubdevID = -1;

  DEBUG_MSG( "close: user closed device file\n" );
  return 0;
}


static int __init init_rtmodule( void )
{
  dev_t dev = 0;
  int retVal = 0;
#ifdef ENABLE_COMPUTATION
#ifdef ENABLE_LOOKUPTABLES
  int k;
#endif
#endif

  // register module device file:
  dev = MKDEV( RTMODULE_MAJOR, 0 );
  retVal = register_chrdev_region( dev, 1, "dynclamp" );
  if ( retVal < 0 ) {
    WARN_MSG( "dynclamp: can't get major %d\n", RTMODULE_MAJOR );
    return retVal;
  }
   
  rtcdev = cdev_alloc();
  rtcdev->ops = &fops;
  rtcdev->owner = THIS_MODULE;
  retVal = cdev_add( rtcdev, dev, 1 );
  if ( retVal )
    ERROR_MSG( "dynclamp: fail to register module with error %d\n", retVal );
  INFO_MSG( "module_init: dynamic clamp module loaded\n" );
  DEBUG_MSG( "module_init: debugging enabled\n" );

  comedi_loglevel( 3 ); 

  mutex_init( &mutex );

#ifdef ENABLE_COMPUTATION
#ifdef ENABLE_LOOKUPTABLES
  for ( k=0; k<MAXLOOKUPTABLES; k++ ) {
    lookupn[k] = 0;
    lookupx[lookupinx] = NULL;
    lookupy[lookupinx] = NULL;
  }
#endif
#endif

  // initialize global variables:
  init_globals();

  return retVal;
}


static void __exit cleanup_rtmodule( void )
{
  int iS;
  dev_t dev = MKDEV( RTMODULE_MAJOR, 0 );

  INFO_MSG( "cleanup_module: dynamic clamp module unloaded\n" );

  // stop and release all subdevices & comedi-devices:
  mutex_lock( &mutex );
  for ( iS = 0; iS < subdevN; iS++ ) {
    if ( stopSubdevice( &subdev[iS], 1 ) )
      WARN_MSG( "cleanup_module: Stopping subdevice with ID %d failed\n", iS );
    releaseSubdevice( iS );
  }
  mutex_unlock( &mutex );

  mutex_destroy( &mutex );

  // unregister module device file:
  cdev_del( rtcdev );
  unregister_chrdev_region( dev, 1 );
}

module_init( init_rtmodule );
module_exit( cleanup_rtmodule );


