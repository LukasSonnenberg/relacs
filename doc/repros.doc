/*!
\page createrepros Create RePro's

\section createreproscontent Content

- \ref createcode (\ref cppintro, \ref reproheaderfile, \ref reprosourcefile)
- \ref setupmakefile
- \ref compilerepro
- \ref addrepro
- \ref debugrepro

RePro's (Reserach Programs) are the central elements of RELACS.
In programming your own %RePro you can create and output stimuli, analyze
the recorded data and the detected events, save data and
results in your preferred format, and display the data in the RePro's widget.
For your own experiments you definitely want to define your
own %RePros to have RELACS doing the experiment on the click of a single button.
The following sections explain how to write your own %RePro.

\section createcode Writing the Code - Basic Concepts

RePro's are C++ classes that inherit the RePro base class from \c repro.h.
If you are not familiar with programming C++ you may want to read
\ref cppintro first.
However, you basically have to write code for a single function.
In addition, RELACS provides some libraries with usefull predefined data types
and functions.
Most sophisticated C++ programming techniques are therefore hidden
behind the scenes.

Before you start writing your code, read \ref naming.

In the %RePro's \b constructor you initialize all the variables,
create the RePro's Options,
and setup the widgets the %RePro is using.
Usually this is the MultiPlot widget which allows you to have
several plots.
The constructor of a %RePro is called once at startup of RELACS.
Therefore you do not want to allocate a lot of memory within
the constructor.

The \b main() function does all the work.
In this function you usually read out the %RePro's options,
allocate necessary memory for the data analysis,
initialize the plot widget, and
display a message in the status bar first.
Then you create a stimulus, 
and repeatedly send the stimulus to the data acquisition board,
\b sleep(), analyze the acquired data and detected events, 
plot and save the results of the analysis,
and modify the stimulus.
Of course, you do not have to stick to this pattern.
Everything else is possible as well.

See also the documentation of the RePro - class for more details.


\subsection reprooptions Options

Usually a %RePro has several parameter that determine 
what the %RePro is supposed to do.
The Options class which is inherited by the RePro class
thrugh the Config class provides a simple interface that allows
to save those parameters to the configuration file,
set them via a dialog window, or from a Macro definition.

To add an option, do something like this 
in the %RePro's constructor:
\code
  addNumber( "duration", "Duration of signal", 0.1, 0.01, 1000.0, 0.01, "seconds", "ms" );
\endcode
The retrieve the value of an option in the 
%RePro's \b main() function do:
\code
  double duration = number( "duration" );
\endcode

Keep in mind, that the user could change the RePro's Options while the 
RePro is running.


\subsection reprostimulus Stimuli
To generate a stimulus, create an OutData variable:
\code
  OutData signal;
  signal.setSampleRate( 20000.0 );
  signal.sineWave( 5000.0, 1.0 );
  signal.setIdent( "sine wave 5kHz 1s" );
  signal.setTrace( "Left-Speaker" );
  signal.setIntensity( 2.0 );
\endcode
In this example, a signal is created with a sampling rate of 
20kHz that is a 5kHz sine wave of 1 second durration.
The signal gets an identifier that is stored in
the \c trigger.dat file where all stimuli are recorded.
The intensity is used to set the attenuation of the signal.

Send it to the data acquisition board with
\code
  write( signal );
\endcode

There is another function which allows you to set 
the output voltage of an output line to zero:
\code
  writeZero( "Right-Speaker" );
\endcode


\subsection repromessages Messages
A message can be displayed in the status bar of RELACS
with the \c message function:
\code
  message( "Loop: <b>5</b>" );
\endcode
You can use simple markup to format the message.
The message string is also written to standard error
and logged into the RELACS log file.


\subsection reprowarnings Warnings
You can open a simple window displaying a warning message
with the \b warning() function:
\code
  warning( "Unable to create stimulus!" );
\endcode
The warning string is also written to standard error
and logged into the RELACS log file.

You can also specify a time in seconds after which the 
warning window is closed automatically:
\code
  warning( "Unable to create stimulus!", 4.0 );
\endcode
If you want to terminate the %RePro right after issuing the warning
you do
\code
  warning( "Unable to create stimulus!", 4.0 );
  return Failed;
\endcode


\subsection reproadjust Adjust the Input Gain

Many data acquisition boards have adjustable input gains.
There are some functions provided by the %RePro class
that allow you to set the input gain of each input channel individually.
For example, to adjust the input gain for the first data trace
such that a maximum value of 2.54 can be read in, do
\code
  adjustGain( trace( 0 ), 2.54 );
  activateGains();
\endcode


\section walkthroughrepro Walktrough Example

Create a class ExampleRePro 
(replace in the following ExampleRePro by an appropriate name)
which inherits RePro.
Save it as file \c myrepro.h.
Implement all the necessary methods in a file \c myrepro.cc.

\subsection reproheaderfile Header File

\dontinclude reproexample.h

Any C/C++ header file should start with
\skip ifndef
\until define
to avoid double inclusion of that header file.
Here, "EXAMPLES" is the name of the pluginset and "REPROEXAMPLE" 
the name of the header file.
At the very end of your header file you have to close the \c #ifndef
with \c #endif.

Then we need to include the repro.h header file
\skipline include
work within the relacs namespace
\skipline using
and define the new RePro within the "examples" namespace
\skipline namespace
(replace "examples" by the name of your plugin set).

Now we can define our new RePro class
\skip author
\skipline class
which inherits the RePro base class.

Since the GUI of RELACS is using the Qt-library,
we need tho call the  \c Q_OBJECT macro
\skipline Q_OBJECT

Then we can define some \c public member functions:
\skipline public

First we need a constructor and a destructor
\skipline ReProExample(
\skipline ~ReProExample
The constructor does not get any arguments.

Most importantly, we need to implement the \b main() function:
\skipline main(

That is all we need in our RePro-class definition.
Close the class and the namespace and don't forget the \c #endif:
\skip };
\until endif


\subsection reprosourcefile Source File

\dontinclude reproexample.cc

First, the header file needs to be included
\skipline include
the relacs namespace to be opened
\skipline using
and the new RePro is defined within the "examples" namespace
\skipline namespace
(replace "examples" by the name of your plugin set).

Then the constructor can be defined
\skip ReProExample
\until }
By calling the constructor of the RePro class,
we give the RePro a name ("ReProExample") that is used to access the
RePro from the menus, config file, and macros,
a title ("RePro - Example") that appears on top of the RePro widget,
the name of the plugin set the RePro belongs to ("Examples"),
the name of the person who wrote the code ("Jan Benda"),
a version string ("1.0"),
and the date of the last modification ("July 8, 2008").
In the body of the constructor we just define a single option.
This option can be modified from the RePro's dialog, the config file,
and the macros.

In our simple example, nothing needs to be done in the destructor
\skip ~ReProExample
\until }

Now it is time for the \b main() function.
This is the place where everything happens.
\skip main
\until {
We read out the option
\until duration
sleep for the desired duration
\skipline sleep
and return
\skipline return
\skipline }
That's it. 
Of course this is a stupid and useless RePro.
It simply does nothing for the requested time.

Don't forget to add the following line to the source code:
\skipline addRePro
This line ensures that RELACS detects your class as a %RePro.

If there are several %RePro classes implemented in a single \c .cc file
you need for each of these %RePros such a line:
\code
addRePro( ExampleRePro1 );
addRePro( ExampleRePro2 );
addRePro( ExampleRePro3 );
\endcode

Finally, the "examples" namespace needs to be closed
\skipline namespace
and the file generated by Qt's moc needs to be included
\skipline include


\section setupmakefile Setup a Makefile

If you do not have a \c Makefile in the directory of your %RePro ExampleRePro,
copy the file \c utils/Makefile.plugins to your directory
and rename it to \c Makefile.

You may have to change a few variables of the \c Makefile:
- \a TOPDIR has to be set to the base path of the RELACS sources
  (usually .. or ../..).
- If you have some subdirectories with \c Makefiles that also
  should be executed, add them to \a SUBDIRS 
  in the order they should be compiled (separated by spaces).
- You might also add these subdirectories to \a VPATH if some
  header files in these subdirectories are included by the %RePro
  (separated by colons,
  see the documentation for \c make for further details (\c info \c make)).

If your %RePro only uses the RELACS include files and libraries
then this is all you have to do and you can continue reading at
\ref compilerepro .
However, if your %RePro uses header and object files other than the %RELACS files,
then you have to add the object files or dynamic libraries to the
\c PLUGINLIB variable
(after the comment "Specify here the dependencies ...").

An example:
Your %RePro is coded in the files \c myrepro.h and \c myrepro.cc.
and uses a library \c libanalysis.so.
Then you have to add the following line to your Makefile:
\code
libmyrepro.so: PLUGINLIB = -lanalysis
\endcode
Suppose the code for your \c Analysis library is in the subdirectory \c ./lib.
Then you should add \c lib to \a SUBDIRS and \a VPATH
\code
SUBDIRS = lib
VPATH = $(RELACSINC):lib
\endcode

Another example:
Suppose the %RePro MyRePro depends on a second library \c libdialogs.so.
Then you have to write: 
\code
libmyrepro.so: PLUGINLIB = -lanalysis -ldialogs
\endcode

Suppose \c libdialogs.so depends on \c libanalysis.so, but your %RePro
does not explicitely use functions from \c libanalysis.so,
then you still have to write
\code
libmyrepro.so: PLUGINLIB = -lanalysis -ldialogs
\endcode
Note that you have to specify both libraries for \c libmyrepro.so!
You have to specify all libraries that are used directly or indirectly
by your %RePro.

To learn more about shared libraries in Linux, read
http://www.linux.org/docs/ldp/howto/Program-Library-HOWTO/shared-libraries.html

\section compilerepro Compile your RePro

If your Makefile and your %RePro-source code is ready, \c cd to
the directory where both files reside.
First run \c make \c depend to get the dependencies of your %RePro right,
and then run \a make to compile the %RePro and link the library:
\code
$> cd myrepro
$> make depend
$> make
\endcode
As a result the library \c libmyrepro.so is created and copied into
the plugins directory.
Now you can run \c relacs and your %RePro should appear in the %RePros menu.
It is also possible to reload a new version of a RePro into the
running RELACS program (menu \c RePros-MyRePro-Load).

If your %RePro is tested carefully and ready for an experiment, type in
\code
$> make install
\endcode
to copy the plugin \c libmyrepro.so into the right directory,
which is specified in the \c Makefile.h by \a PLUGINSINSTALLPATH.


\section addrepro Adding a new RePro to RELACS

Make sure that the path, where the shared library of your %RePro resides,
is specified in \c pluginpathes in \c relacs.cfg.

You may want your %RePro to appear as a button in the RELACS program.
For that purpose edit the macros configuration file appropriately.
Read \ref macros for an introduction.

\note 
For succesfully finding and loading plugin libraries it is necessary that
the environment variable \c LD_LIBRARY_PATH contains the directories
of the plugins, and the libraries they depend on.
If the libraries a plugin depends on reside in the same directory
as the plugin, then it is sufficient to add the current working directory
to \c LD_LIBRARY_PATH by adding a colon to the front
(which is the default setting in the \c relacs skript).
Additional pathes have to be added manually in the \c relacs script.
Alternatively, you can specify the location of a library in the 
runpath of a plugin during compilation by something like this:
\code
g++ -o libmyrepro.so myrepro.o -shared -Wall -L/directory/of/dependent/library -Wl,-rpath,/directory/of/dependent/library -lname
\endcode
The library \c libname.so is located in \c /directory/of/dependent/library ,
and \c -Wl,rpath,... defines the runpath.


\section debugrepro Debugging your RePro

If RELACS crashes (due to an error in a %RePro), you may want to know why
this happened. 
You cannot use a debugger directly,
since the LD_LIBRARY_PATH environment variable must be set beforehand
such that the RELACS executable \c relacsexec finds the necessary libraries and plugins.

For your convinience, the \c relacs script supports a \c -d and \c -D option
that does all the necessary things and finally starts the GNU debugger \c gdb.
\c -d directly runs RELACS from within the debugger, whereas \c -D starts
the debugger but you have to run RELACS manually.
If you do not want to use \c gdb as the debugger, you can edit
the \c DEBUGGER variable in the \c relacs script.

After RELACS crashed, \c gdb tells you where this happened,
i.e. in which function on which line of which file.
Usefull commands for \c gdb are:
\arg \c bt (backtrace): shows you all the functions on the stack
\arg \c up, \c down: Select the calling or called function
\arg \c info \c thread: List all the threads
\arg \c thread \c n: Switch to thread \a n
\arg \c print: Show the value of variables
\arg \c quit: Quit the debugger
\arg \c help: Help. You can call help with a command name in order 
              to find out more about the command, like \c help \c bt.

In case you want to start the debugger manually you have to set the
search path to the RELACS shared libraries and the plugins by executing
the following line
\code
export LD_LIBRARY_PATH=:./lib:./plugins:$LD_LIBRARY_PATH
\endcode
Now you can run the RELACS executable \c relacsexec with the debugger:
\code
gdb relacsexec
\endcode
To start RELACS in simulation mode, type 
\code
run -3
\endcode
into the gdb prompt.

<hr>

Continue reading with \ref relacsprogram,
go to the top of this page \ref createrepros,
or go to the table of contents \ref maincontent

*/
