/*!
\page naming Naming Conventions

The following naming conventions for files, classes, function, variables, etc.
intend to simplify the usage of RELACS-related libraries.


\section filenames File names

It is a generally accepted standard to use lowercase file names
for all source code and header files
and to use the extensions \c .cc and \c .h, respectively.
Ideally, each source code file contains just one class.
The source code files should have the same name as the class they contain.

Example: If the class is named \c MyClass, then the source code and the header file
are named
\code
myclass.h
myclass.cc
\endcode

The standard name for makefiles is 
\code
Makefile
\endcode


\section compoundnames Classes, functions, and variables

In naming classes, function, variables, etc. we follow the convention
used by the Qt library.
No underscores '_' are used.

For example, use
\code
ThisIsMyVariable
\endcode
instead of
\code
this_is_my_variable
\endcode

The only exception is \c const_iterator to conform with the STL
(http://www.sgi.com/tech/stl/).


\subsection typenames Classes, structs, typedefs, enums

Class, struct, and typedef names start with an uppercase letter.

Example:
\code
class MyClass;
\endcode

Enum types as well as their members also start with an uppercase letter.

Example:
\code
enum Color { Transparent=-1, Black=0, White, Red, Green, Blue };
\endcode


\subsection functionnames Member Functions

Member functions have a lowercase first letter.
Their arguments and local variables are all lowercase.
Use the \c const keyword for the arguments and the function 
whenever it is appropriate.
Functions that set variables of a class are named \c setXXX().
Functions retrieving data from a class \b don't start with \c get (\c getXXX()),
instead they are just named \c xxx() to keep the code better readable.

Examples:
\code
void setText( const string &text, int flag );  // set some text to \a text
double width( void ) const;                    // returns a width

if ( width() > 0 ) ...        // reads better than: if ( getWidth() > 0 )
\endcode


\subsection variablenames Member Variables

Member variables are \b never public!
Use (inline) member functions to provide acsess to member variables.
Use an uppercase first letter for member variables
to avoid conflicts with the corresponding member function
and local variables.

Example:
\code
class MyClass
{
  public:

      // Return the value of the member variable \a Number:
    inline double number( void ) const { return Number; };

      // Set the value of the member variable \a Number to \a number:
    inline void setNumber( double number ) { Number = number; };

  private:

      // A member variable:
    double Number;
};
\endcode


\section functionstandard Standard function names

For reading and writing files use
\code
void load( ... );
void save( ... );
\endcode
respectively.

For reading and writing to devices use
\code
void read( ... );
void write( ... );
\endcode


\subsection containerstandard Standard container member functions

A container is a class which organizes an array of some data type \c T.
For these classes the following standard functions are usefull
and should be provided if possible.
They conform to the STL (http://www.sgi.com/tech/stl/).

\code
int size( void ) const;
\endcode
Returns the number of data elements the container currently holds.

\code
bool empty( void ) const;
\endcode
Returns true if there aren't any data elements stored in the container.
Equivalent to \c ( \c size() \c == 0 \c ).

\code
void resize( int newsize, T dflt=0 );
\endcode
Changes the number of data elements to \a newsize. If this number is larger
than the size of the container, then the new data elements are initialized with
\a dflt.

\code
void clear( void );
\endcode
Removes all data elements from the container.
Equivalent to \c resize( \c 0 \c ).


\code
int capacity( void ) const;
\endcode
The maximum number of data elements the container can hold
without reallocating memory.

\code
void reserve( int newsize );
\endcode
Allocates memory so that the container can hold at minimum \a newsize
data elements.
If \a newsize is larger than the size of the container
all data elements are kept and the size does not change.
If \a newsize is smaller, then nothing is done,
the container will keep its previous capacity().


\code
T operator[]( int index ) const;
T &operator[]( int index );
\endcode
Read and set the data element specified by \a index.
No range checking is performed in order to optimize performance speed.
You have to make sure that \a index specifies an existing data element.

\code
T at( int index ) const;
T &at( int index );
\endcode
Read and set the data element specified by \a index.
In contrast to \c operator[] these functions first check the validity
of \a index.

\code
T front( void ) const;
T &front( void );
T back( void ) const;
T &back( void );
\endcode
Read and set the first or last data element, respectively.
You have to make sure that they really exist, i.e. that the container is not
empty().

\code
void copy( int range, T *data ) const;
void copy( int range, vector< T > &data ) const;
\endcode
The \c copy functions allow to copy a range of data elements of the container
to different types of container \a data.

\code
void assign( T *data, int range );
void assign( vector< T > &data, int range );
\endcode
The \c assign functions allow to copy a range of data elements from
different types of containers \a data into the container.
Before copying data all data elements of the container are removed.

\code
void append( T *data, int range );
void append( vector< T > &data, int range );
\endcode
The \c append functions allow to append a range of data elements from
different types of containers \a data to the already existing data elements
of the container.

\code
const_iterator begin( void ) const;
const_iterator end( void ) const;
\endcode
Return an iterator to the first and behind the last element of the container,
respectively.

<hr>

Continue reading with \ref relacsstructure,
go to the top of this page \ref naming,
or go to the table of contents \ref maincontent

*/
